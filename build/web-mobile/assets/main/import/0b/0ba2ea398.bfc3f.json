[1,["01d132ba-1bf4-4679-95ff-8b809cf98590","fda095cb-831d-4601-ad94-846013963de8","9567f5c7-10ec-434d-9d3c-06349f14a00d@f9941","1d6eae53-c9f3-4741-a592-30457f686726@f9941","c54ae427-6cdd-4bd0-b460-d7824bcac958@f9941","ea1a8c39-2a74-4df7-843e-b12230708d7c@f9941","1e386ee6-6018-4cef-8635-a2a08f77366d","9561e327-97d4-45ff-86f5-b0bb7502a74c@f9941","f12a23c4-b924-4322-a260-3d982428f1e8@f9941","20835ba4-6145-4fbc-a58a-051ce700aa3e@f9941","5912bea9-6c06-4be6-8c6a-8d8ea19157b7","951249e0-9f16-456d-8b85-a6ca954da16b@f9941","bad5f427-d743-46cb-84c3-5df9d3a9897c","bd1bcaba-bd7d-4a71-b143-997c882383e4@f9941","7d8f9b89-4fd1-4c9f-a3ab-38ec7cded7ca@f9941","1baf0fc9-befa-459c-8bdd-af1a450a0319","544e49d6-3f05-4fa8-9a9e-091f98fc2ce8@f9941","1e386ee6-6018-4cef-8635-a2a08f77366d@09edf","bad5f427-d743-46cb-84c3-5df9d3a9897c@9bce9","83a9cf14-cb41-404b-b7b6-34067b8004cb","bad5f427-d743-46cb-84c3-5df9d3a9897c@25e4d","bad5f427-d743-46cb-84c3-5df9d3a9897c@a0e01","99467415-1908-45e8-89dc-afb5019a61cc@f9941","0dbcea57-1096-45a5-910e-4be28575c4be@f9941","f8df3841-9e7b-4021-90ae-b04437a3205f@f9941","57520716-48c8-4a19-8acf-41c9f8777fb0@f9941","ff2e4244-7c30-4d8c-8708-2ec6791c739a","bad5f427-d743-46cb-84c3-5df9d3a9897c@b27e7","05f48a00-1471-4c32-88f3-ef3f91961327@f9941","bad5f427-d743-46cb-84c3-5df9d3a9897c@dab52","93121420-9878-476b-a24a-2c737741d92c@f9941","9cb59372-2c8c-4260-b3b3-b5747b4dabff@f9941","bad5f427-d743-46cb-84c3-5df9d3a9897c@d3735","2d971648-6733-4147-99cb-bf34a34c6d83@f9941","ad844153-144d-4d11-b2e3-1b0811127e35","5adaa466-60ae-4a34-a9c1-d95be985b9a3","b5b27ab1-e740-4398-b407-848fc2b2c897@6c48a","aee3107f-f31e-46f6-9b04-412999f29709","b31d8f5c-4c73-4aa6-a6b8-af05adcf336e@f9941","d346844d-70ff-46d7-88c8-d3eae8bb296c@f9941","158e7e52-3220-4cd7-9694-713e0e6e8278@f9941","bad5f427-d743-46cb-84c3-5df9d3a9897c@0e6b5","0da256a2-21f6-481b-90b6-d3643a09179b@6c48a","158e7e52-3220-4cd7-9694-713e0e6e8278@6c48a","20835ba4-6145-4fbc-a58a-051ce700aa3e@6c48a","24a704da-2867-446d-8d1a-5e920c75e09d@6c48a","28765e2f-040a-4c65-8e8c-f9d0bb79d863@6c48a","e35275e3-185c-47fd-a07e-5e652913aa76@6c48a","1e386ee6-6018-4cef-8635-a2a08f77366d@9883b","7e94dcd0-14a8-43b4-a477-6900f251f502","bad5f427-d743-46cb-84c3-5df9d3a9897c@d1a7c","bad5f427-d743-46cb-84c3-5df9d3a9897c@94fc1","20055d4d-7f2b-47ab-9e05-cfd9d4628a00@f9941","bad5f427-d743-46cb-84c3-5df9d3a9897c@8a970","bad5f427-d743-46cb-84c3-5df9d3a9897c@c3f25","28765e2f-040a-4c65-8e8c-f9d0bb79d863@f9941","f27a571a-68a9-42b0-bf08-204a51c701b9@f9941","054ee669-4d3b-47e9-a6e0-814e24b9e5dc","820f2425-92a8-4511-b1b2-b30cdc8bbdf2","8640dc1a-063a-4d6c-817a-ec4b296139e5","ea7478b0-408d-4052-b703-f0d2355e095f","9c4cf238-b5a1-4b42-aa9c-0bc4159a83d7","e8484972-dcca-4084-b9a5-5473c21ae42c","3f8d82cd-9d21-44a4-a60d-a5f522aaed83","0f748da6-4dc5-420d-aff5-58e023d86f4b","0b7751cb-e5e3-4de7-89b8-ea84a3999f04","3e765ceb-2e14-43f1-ab23-0e9c5a2f099e","484016cf-41ca-4bb8-afb9-c6dd8f102fe4","307f2587-0f55-4f3e-9abe-bcdbb357f983","afc47931-f066-46b0-90be-9fe61f213428@f9941","2fb60004-39f6-4220-859f-298f270726d6@f9941","0da256a2-21f6-481b-90b6-d3643a09179b@f9941","1daf5c9a-2f04-4b93-b01b-e398bbb32a88@f9941","edf0095b-427d-44d9-9867-8baae15d79bc@6c48a","544e49d6-3f05-4fa8-9a9e-091f98fc2ce8@6c48a","57520716-48c8-4a19-8acf-41c9f8777fb0@6c48a","3dd47cd2-687d-4f11-ae9a-a63680309b7b","7e2b3471-aa4d-4f17-9dea-164c2551b7ef@02e33","51dc0c42-1048-4ce1-8a7c-6edf0e50f66f","1263d74c-8167-4928-91a6-4e2672411f47@17020","7d8f9b89-4fd1-4c9f-a3ab-38ec7cded7ca@6c48a","bad5f427-d743-46cb-84c3-5df9d3a9897c@9cd14","0eb9e669-9414-451b-b093-ef852405891e@6c48a","951249e0-9f16-456d-8b85-a6ca954da16b@6c48a","9fd900dd-221b-4f89-8f2c-fba34243c835@6c48a","afc47931-f066-46b0-90be-9fe61f213428@6c48a","bd1bcaba-bd7d-4a71-b143-997c882383e4@6c48a","d1346436-ac96-4271-b863-1f4fdead95b0","f12a23c4-b924-4322-a260-3d982428f1e8@6c48a","60f7195c-ec2a-45eb-ba94-8955f60e81d0","9fd900dd-221b-4f89-8f2c-fba34243c835@f9941","8390df74-f91c-4e55-923d-587513b748e5@f9941","24a704da-2867-446d-8d1a-5e920c75e09d@f9941"],["node","_spriteFrame","_font","targetInfo","value","_parent","_normalSprite","_customMaterial","root","_hoverSprite","_pressedSprite","_disabledSprite","_target","_textureSource","_atlas","asset","data","_effectAsset","_checkMark","mainTexture","source","_placeholderLabel","_textLabel","_userDefinedFont","target","_scrollView","_backgroundImage","_mesh","_cameraComponent","emergency","upgrade","planetPanel","manager","backButton","resButton","itemContent","layout","_particleSystem","scene","listView","toggleButton","optionLabel","_handle","optionText","camera","itemTiny","settingPrefab","bgm","_mainTexture","_defaultClip","planet","ring","spot","light","sphere","_imageAtlas","_barSprite"],[["cc.Widget",["_alignFlags","_originalWidth","_top","_left","_right","_originalHeight","_bottom","_verticalCenter","_isAbsTop","_isAbsLeft","_alignMode","_horizontalCenter","_isAbsRight","_isAbsBottom","node","__prefab"],-11,1,4],["cc.Label",["_actualFontSize","_string","_fontSize","_lineHeight","_overflow","_cacheMode","_isSystemFontUsed","_horizontalAlign","_enableWrapText","_underlineHeight","_verticalAlign","_isBold","node","__prefab","_font","_color","_customMaterial"],-9,1,4,6,5,6],["cc.Node",["_name","_layer","_objFlags","_active","_id","_components","_parent","_children","_prefab","_lpos","_lscale","_lrot","_euler"],-2,9,1,2,4,5,5,5,5],["cc.Node",["_name","_layer","_active","_objFlags","_id","_components","_parent","_lpos","_children","_prefab","_lrot","_euler","_lscale"],-2,12,1,5,2,4,5,5,5],["cc.Sprite",["_sizeMode","_type","_isTrimmedMode","node","__prefab","_spriteFrame","_color","_customMaterial","_atlas"],0,1,4,6,5,6,6],"cc.SpriteFrame",["cc.Layout",["_layoutType","_resizeMode","_spacingX","_paddingTop","_spacingY","_paddingBottom","_isAlign","_paddingLeft","_constraint","_constraintNum","_startAxis","_horizontalDirection","_paddingRight","node","__prefab","_cellSize"],-10,1,4,5],["cc.Button",["_transition","_zoomScale","_interactable","_enabled","node","clickEvents","__prefab","_target","_normalSprite","_normalColor","_hoverSprite","_pressedSprite","_disabledSprite","_hoverColor","_pressedColor","_disabledColor"],-1,1,9,4,1,6,5,6,6,6,5,5,5],["cc.RichText",["_string","_lineHeight","_fontSize","_isSystemFontUsed","_maxWidth","_horizontalAlign","node","__prefab","_font","_userDefinedFont","_imageAtlas"],-3,1,4,6,6,6],["cc.Toggle",["_transition","_isChecked","_zoomScale","node","_checkMark","_normalSprite","checkEvents","__prefab","_target","_normalColor","_hoverColor","_pressedColor","clickEvents","_disabledColor","_hoverSprite","_pressedSprite","_disabledSprite"],0,1,1,6,9,4,1,5,5,5,9,5,6,6,6],["cc.Node",["_name","_id","_layer","_active","_parent","_components","_lrot","_euler","_lpos","_lscale","_prefab","_children"],-1,1,2,5,5,5,5,4,2],["cc.UITransform",["node","_contentSize","_anchorPoint","__prefab"],3,1,5,5,4],["cc.UIOpacity",["_opacity","node","__prefab"],2,1,4],["cc.LabelOutline",["_width","node","_color","__prefab"],2,1,5,4],["cc.EditBox",["_string","_inputMode","_maxLength","_returnType","node","__prefab","_textLabel","_placeholderLabel","editingDidEnded","_backgroundImage"],-1,1,4,1,1,9,6],["cc.Material",["_defines","_states","_techIdx","_props"],0,12],["cc.ClickEvent",["_componentId","handler","customEventData","target"],0,1],["cc.ToggleContainer",["_allowSwitchOff","node","checkEvents","__prefab"],2,1,9,4],["cc.CurveRange",["constant","mode","curveMin","curveMax"],1,4,4],"cc.SpriteAtlas",["cc.PrefabInfo",["fileId","root","asset","targetOverrides"],2,1,1,9],["cc.EffectAsset",["_name","shaders","techniques","combinations"],-1],["cc.BlockInputEvents",["node","__prefab"],3,1,4],["a3df7Hq+dRF8ZAchtDwvZpr",["node","blocks"],3,1,2],["cc.Mask",["node","__prefab"],3,1,4],["cc.PrefabInstance",["fileId","propertyOverrides","mountedComponents"],2,9,9],["cc.TargetOverrideInfo",["propertyPath","source","target","targetInfo","sourceInfo"],2,1,1,4,4],["cc.ScrollBar",["_enableAutoHide","_direction","node","__prefab","_handle"],1,1,4,1],["cc.Camera",["_clearFlags","_visibility","_projection","_priority","_orthoHeight","_far","_fov","node","_color"],-4,1,5],["cc.ScrollView",["bounceDuration","brake","horizontal","vertical","node","__prefab","_content","_verticalScrollBar","_horizontalScrollBar"],-1,1,4,1,1,1],["cc.StaticLightSettings",["_bakeable"],2],["cc.GradientRange",["_mode","gradient"],2,4],["cc.ColorKey",["time","color"],2,5],["cc.Keyframe",["time","value","inTangent","outTangent"],-1],["cc.MeshRenderer",["_name","_shadowReceivingMode","node","__prefab","_materials","lightmapSettings","_mesh"],1,1,4,3,4,6],["cc.ModelLightmapSettings",["_bakeable"],2],["cc.TTFFont",["_name","_native"],1],["cc.Prefab",["_name"],2],["cc.CompPrefabInfo",["fileId"],2],["a08a7AlMIFE9K6keMbSUgik",["node","__prefab"],3,1,4],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.JsonAsset",["_name","json"],1],["cc.Mesh",["_native","_dataLength","_hash","_struct"],0,11],["cc.Material",["_props","_defines"],1],["c12ffm5DVtDNZZjvi1e8EY3",["node","__prefab","contents"],3,1,4,2],["cc.SceneAsset",["_name"],2],["cc.Canvas",["node","_cameraComponent"],3,1,1],["472b4yu8a9PjKp5Zk4EdQK+",["node","blocks","backButton","manager","listViews","planetPanel","boards","upgrade","emergency","scenes","settingPrefab","bgm"],3,1,2,1,1,2,1,2,1,1,2,6,6],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,1],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["cc.TargetInfo",["localID"],2],["cc32ae4iWRCbpNIabux8iPV",["node","buttonImages","itemContent","layoutContent","resButton"],3,1,3,1,1,1],["8f788lsOqdMz6vT2lcxsdp6",["node"],3,1],["f1d24/Ot3NECaoIY5KhB+6k",["node","buttons","icons","layout","itemTiny"],3,1,2,3,1,6],["4a17d+ghpBK95Q0DzfCe0Yj",["node"],3,1],["cc.MountedComponentsInfo",["components","targetInfo"],2,4],["cc.RenderRoot2D",["_name","node"],2,1],["f632ftPvRFPNKlhQkgnKHKm",["node","dataAssets","atlasAssets","prefabAssets"],3,1,3,3,3],["cc.AudioSource",["_loop","_playOnAwake","node"],1,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",["_skyColor","_groundAlbedo"],3,5,5],["cc.ShadowsInfo",["_bias"],2],["cc.SkyboxInfo",[],3],["cc.FogInfo",["_enabled","_fogEnd"],1],["cc.LabelShadow",["_blur","node","_color","_offset"],2,1,5,5],["cc.Graphics",["_lineWidth","node"],2,1],["940d4XZy2ZHpZq0HhvR6iwH",["node","toggleEvent"],3,1,9],["cc.Animation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["cc.RigidBody",["_allowSleep","_linearDamping","_angularDamping","_useGravity","node"],-1,1],["e87ccmHB/dHKaFFj+u3apVf",["node"],3,1],["53d46riXTpJo6q8nepchkB3",["node","layouts","listBox","itemPrefabs"],3,1,2,1,3],["9d3a1sSv+xAC6neeQPJ008d",["firstFadeIn","node","blocks","listViews","prefabs"],2,1,2,2,12],["5be8fkH4/pByLwK+DfEAvdQ",["node","layout"],3,1,1],["3e845TVW4xA0oNuoC86M9cP",["node"],3,1],["cc.DirectionalLight",["_useColorTemperature","_illuminance","node","__prefab","_color","_staticSettings"],1,1,4,5,4],["cc.ParticleSystem",["_capacity","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],2,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.Gradient",["colorKeys","alphaKeys"],3,9,9],["cc.AlphaKey",["alpha","time"],1],["cc.ShapeModule",["_enable","_shapeType","emitFrom","radius","arcSpeed"],-1,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.AnimationCurve",["preWrapMode","postWrapMode","keyFrames"],1,9],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.LimitVelocityOvertimeModule",["limitX","limitY","limitZ","limit"],3,4,4,4,4],["cc.RotationOvertimeModule",["x","y","z"],3,4,4,4],["cc.TextureAnimationModule",["frameOverTime","startFrame"],3,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["050e8MfAYJIY7F1LGwZGe5Y",["node","__prefab"],3,1,4],["51033u3TQlGPK9J3JmvofEz",["node","__prefab","sphere","light","spot","ring"],3,1,4,1,1,1,1],["cc.SpotLight",["_useColorTemperature","_colorTemperature","_size","_luminance","_term","_range","node","__prefab","_staticSettings"],-3,1,4,4],["cc.SphereLight",["_useColorTemperature","_colorTemperature","_size","_luminance","_range","node","__prefab","_staticSettings"],-2,1,4,4],["cc.AudioClip",["_name","_native","_duration"],0],["ad771uHkU9Ie6kqIUGtIKpk",["node"],3,1],["008d9PrPqpIhaDsOHyFgyyV",["node","toggles","sliders"],3,1,2,2],["cc.Slider",["_progress","node","__prefab","slideEvents","_handle"],2,1,4,9,1],["cc.AnimationClip",["_name","sample","wrapMode","_duration","_hash","_keys","_curves"],-3,12],["cc.animation.ComponentPath",["component"],2],["0f160ooyztADp3cT6Hj7E4q",["node","__prefab"],3,1,4],["cc.ProgressBar",["_totalLength","_progress","node","__prefab","_barSprite"],1,1,4,1]],[[38,0,2],[11,0,3,1,1],[11,0,3,1,2,1],[20,0,1,2,2],[2,0,1,6,5,9,3],[54,0,2],[2,0,1,6,7,5,9,3],[12,1,1],[12,1,2,1],[49,0,1,2,2],[16,0,1,3,3],[11,0,1,1],[18,1],[4,1,0,3,4,5,3],[50,0,1,2,2],[48,0,1,2,3],[1,1,7,0,2,3,4,6,5,12,13,14,9],[51,0,1,2,2],[2,0,2,1,6,5,4],[0,0,1,5,14,4],[2,0,1,6,5,8,9,3],[2,0,1,7,5,9,3],[1,1,0,2,3,4,8,6,5,12,13,14,9],[0,0,3,4,1,14,5],[40,0,1,2,3,2],[4,0,3,4,5,2],[7,0,4,6,5,9,7,8,10,11,12,2],[37,0,2],[2,0,1,6,5,3],[3,0,1,6,5,7,3],[0,0,3,4,2,6,1,5,14,8],[1,1,0,2,4,8,12,13,6],[2,0,1,6,7,5,3],[0,0,3,4,2,1,14,15,6],[0,0,2,6,1,5,14,6],[0,0,3,4,2,1,14,6],[0,0,3,14,3],[4,1,0,3,4,3],[25,0,1,2],[4,1,0,3,5,3],[18,0,2],[2,0,2,1,6,5,9,4],[2,0,1,6,7,5,8,9,3],[3,0,1,6,8,5,7,3],[0,0,3,2,1,14,15,5],[0,0,3,2,14,4],[0,0,4,2,14,4],[0,0,3,2,1,14,5],[1,1,7,0,2,3,4,12,13,15,7],[41,0,1,3],[16,0,1,2,3,4],[24,0,1],[2,0,2,1,6,5,8,9,4],[2,0,1,7,5,8,3],[2,8,1],[2,0,3,1,6,7,5,9,4],[2,6,8,1],[2,0,3,1,6,5,9,4],[0,0,3,4,1,14,15,5],[0,0,14,15,2],[4,1,0,3,4,6,7,5,8,3],[1,1,7,0,2,3,4,6,5,12,13,15,14,9],[6,1,0,2,13,14,4],[26,0,1,4,2,3,2],[2,0,1,7,5,3],[3,0,1,6,5,9,7,3],[3,0,2,1,6,5,4],[3,0,1,6,8,5,9,7,3],[0,0,6,11,14,4],[0,0,3,14,15,3],[4,1,0,3,4,7,5,3],[1,1,7,0,2,3,4,12,13,7],[1,1,0,2,3,4,6,5,12,13,14,8],[1,1,0,2,3,12,13,5],[1,1,0,2,3,4,8,6,5,12,13,15,14,9],[8,1,0,2,4,6,7,5],[6,1,0,3,5,4,13,14,6],[6,1,0,2,6,13,14,5],[6,0,7,12,2,13,14,5],[7,0,1,4,6,5,9,7,8,3],[23,0,1],[26,0,1,2,3,2],[33,0,1,2,3,5],[2,0,2,1,6,5,8,4],[2,0,3,1,6,7,5,4],[2,0,7,5,8,2],[3,0,2,1,6,8,5,7,4],[11,0,1,2,1],[0,0,14,2],[0,0,2,6,7,14,5],[4,1,0,3,4,6,5,3],[1,1,0,2,3,6,9,5,12,13,16,14,8],[6,1,0,4,13,14,4],[13,0,1,2,2],[16,1],[31,1],[2,0,1,7,5,8,9,3],[2,0,1,6,5,8,3],[2,0,2,1,6,5,8,10,4],[3,0,3,1,6,5,7,4],[3,0,3,2,1,6,5,7,5],[3,0,3,1,6,5,9,12,4],[3,0,3,1,6,5,9,4],[11,0,2,1],[0,0,2,1,14,15,4],[0,0,4,2,6,1,5,14,7],[0,0,2,14,3],[0,0,6,14,3],[0,0,1,5,10,14,15,5],[4,0,3,4,6,5,2],[4,1,0,3,4,7,5,8,3],[4,1,3,2],[4,0,3,4,5,8,2],[4,1,0,3,4,6,3],[4,3,4,7,5,8,1],[4,0,2,3,4,3],[1,1,7,0,2,3,4,6,11,5,12,13,14,10],[1,1,0,2,3,4,6,5,12,14,8],[1,1,0,2,4,8,12,13,15,6],[1,1,7,0,2,4,8,6,12,13,15,8],[1,1,7,0,2,3,4,8,6,12,13,15,9],[1,1,7,0,2,4,8,5,12,13,8],[1,1,7,0,2,3,4,8,12,13,15,8],[42,0,1,2,3,4],[21,0,1,2,4],[8,1,0,5,2,4,6,7,6],[12,0,1,2],[15,1,0,3,3],[6,1,0,13,3],[13,0,1,3,2],[7,2,0,4,6,5,9,7,8,10,11,12,3],[7,0,1,4,6,13,15,7,3],[22,0,1],[24,0,1,1],[25,0,2,1,2],[9,0,3,7,9,10,11,8,6,4,2],[56,0,1],[58,0,1],[59,0,1,2],[62,0,1,2,3],[17,0,1,3,2],[17,1,3,2,1],[30,1],[83,0,1,3],[86,0,1,2,3],[33,1],[94,0,1,1],[101,0,1,2,3,4,2],[36,0,1,3],[2,0,1,5,8,9,3],[2,0,1,4,7,5,9,4],[2,0,3,1,7,5,4],[2,0,2,4,7,5,4],[2,0,6,7,5,9,2],[2,0,3,1,6,5,4],[2,0,4,6,5,9,11,12,3],[2,0,6,7,5,8,9,10,2],[2,0,6,5,8,10,2],[2,0,1,6,7,5,8,3],[2,0,3,1,6,7,5,8,9,4],[3,0,1,8,5,7,3],[3,0,1,6,8,5,3],[3,0,2,1,6,8,5,4],[3,0,1,8,5,3],[3,0,4,6,5,7,10,11,3],[3,0,1,6,5,3],[3,0,2,1,6,5,7,4],[3,0,2,1,6,5,9,7,4],[10,0,1,4,11,5,6,7,3],[10,0,2,4,5,8,3],[10,0,1,4,5,6,9,7,3],[10,0,4,5,10,8,6,9,7,2],[10,0,3,4,5,10,3],[0,0,2,8,14,15,4],[0,0,4,14,3],[0,0,3,2,6,9,1,5,14,8],[0,0,3,2,6,1,5,14,7],[0,0,4,6,1,5,14,6],[0,0,4,2,1,5,14,6],[0,0,2,7,14,4],[0,0,3,4,2,6,12,1,5,14,9],[0,0,5,14,3],[0,0,2,8,1,14,15,5],[0,0,4,6,14,4],[0,0,4,2,6,5,14,6],[0,0,3,4,6,9,1,5,14,8],[0,0,5,10,14,15,4],[0,0,3,4,1,5,14,6],[0,0,3,4,2,6,7,1,5,14,9],[0,0,2,1,14,4],[0,0,3,4,14,4],[0,0,4,2,1,14,15,5],[0,0,3,4,2,14,5],[0,0,3,2,7,1,14,15,6],[0,0,1,5,14,15,4],[0,0,6,13,14,15,4],[0,0,3,4,6,1,14,15,6],[0,0,5,14,15,3],[39,0,1,1],[20,3,1],[4,0,3,6,7,5,2],[4,1,0,3,3],[4,0,3,4,6,7,5,2],[1,1,7,10,0,2,3,4,6,9,5,12,13,11],[1,1,7,10,0,2,3,4,6,9,5,12,13,15,11],[1,1,7,0,2,3,9,12,15,16,7],[1,1,0,2,3,6,5,12,13,15,14,7],[1,1,0,6,9,12,15,16,14,5],[1,1,0,2,3,4,6,12,13,15,14,7],[1,1,7,10,0,3,4,6,5,12,13,14,9],[1,1,0,2,3,4,12,6],[1,1,0,6,5,12,13,14,5],[1,1,7,0,2,3,4,5,12,13,8],[1,1,7,0,2,3,4,5,12,13,15,8],[1,1,7,0,2,3,4,8,6,5,12,13,14,10],[1,1,0,2,3,4,5,12,7],[1,1,0,2,3,5,12,13,6],[1,1,0,2,12,13,4],[1,0,2,3,4,6,5,12,13,14,7],[1,1,0,2,3,4,5,12,13,15,7],[1,1,0,2,4,8,5,12,13,7],[1,1,0,2,3,4,12,13,6],[1,1,0,6,9,5,12,13,15,16,14,6],[1,1,0,2,3,6,9,5,12,13,15,16,14,8],[1,1,0,2,4,8,6,9,5,12,13,16,14,9],[21,0,3,1,2,5],[8,0,5,3,6,7,8,4],[8,1,0,2,4,6,7,9,5],[8,1,0,2,3,6,7,5],[8,1,0,2,3,6,7,8,9,10,5],[12,0,1,2,2],[15,2,1,0,3,4],[15,0,3,2],[43,0,1,3],[44,0,1,2,1],[6,0,3,5,4,13,14,5],[6,1,0,3,8,9,13,14,15,6],[6,0,3,13,3],[6,1,0,10,4,6,13,6],[6,1,0,7,3,5,2,4,13,14,8],[6,0,2,11,13,4],[6,0,2,13,14,3],[13,0,1,3,2,2],[13,1,2,1],[45,0,2],[46,0,1,1],[47,0,1,2,3,4,5,6,7,8,9,10,11,1],[7,4,5,1],[7,3,4,5,2],[7,4,5,8,1],[7,0,1,4,6,5,9,7,8,10,11,12,3],[7,0,4,5,2],[7,2,0,4,6,5,9,7,3],[7,4,6,5,13,14,7,8,1],[7,0,4,6,5,9,13,14,15,7,8,10,11,12,2],[22,0,1,1],[23,0,1,1],[52,0,1,2,3],[53,0,1,2,2],[55,0,1,2,3,4,1],[9,0,1,3,8,6,4,5,3],[9,0,3,12,9,10,11,13,4,5,14,15,16,2],[9,1,3,6,4,5,2],[9,0,2,1,3,7,6,4,5,4],[9,0,1,3,7,4,5,3],[57,0,1,2,3,4,1],[60,0,1,2],[61,0,1,2,3,1],[63,0,1,2,3,2],[64,0,1,2,3,1],[65,0,1,1],[66,0,2],[67,1],[68,0,1,3],[14,0,1,2,4,5,8,6,7,4],[14,3,0,1,2,4,5,8,6,7,9,5],[14,0,1,2,4,5,6,7,4],[14,0,1,2,4,5,8,6,7,9,4],[69,0,1,2,3,2],[17,0,1,2,2],[70,0,1,2],[71,0,1,1],[72,0,1,2,3,2],[73,0,1,2,3,4,5],[74,0,1],[27,0,2,3,2],[27,1,2,3,4,2],[75,0,1,2,3,1],[28,2,3,4,5,0,1,7,8,7],[28,6,0,1,7,4],[29,0,1,2,4,5,6,7,4],[29,0,1,3,4,5,6,8,7,4],[76,0,1,2,3,4,2],[77,0,1,1],[78,0,1],[79,0,1,2,3,4,5,3],[30,0,2],[80,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2],[31,0,1,2],[18,1,2,3,2],[81,0,1,2],[82,0,1,1],[32,1,1],[32,0,1,2],[84,0,1,2,3,4,5],[85,0,1,2,3,4,2],[87,0,1,2,3,1],[88,0,1,2,1],[89,0,1,2,3,1],[90,0,1,2,1],[91,0,1,1],[92,0,1,2,3,4,1],[93,0,1],[95,0,1,2,3,4,5,1],[34,0,1,2,3,4,5,6,3],[34,0,2,3,4,5,6,2],[35,0,2],[35,1],[96,0,1,2,3,4,5,6,7,8,7],[97,0,1,2,3,4,5,6,7,6],[98,0,1,2,4],[99,0,1],[100,0,1,2,1],[102,0,1,2,3,4,5,6,7],[103,0,2],[104,0,1,1],[105,0,1,2,3,4,3]],[[[[148,"文泉驿等宽微米黑（WenQuanYi Micro Hei Mono）","文泉驿等宽微米黑（WenQuanYi Micro Hei Mono）.ttf"]],0,0,[],[],[]],[[[27,"valueChangeItem"],[96,"valueChangeItem",33554432,[-5,-6,-7,-8,-9,-10],[[1,-2,[0,"c68UOAlNhN171Umca6yVvF"],[5,1260,32]],[33,40,10,10,90.24000000000001,380,-3,[0,"23i7b15qNKu7mC/8dRZYLX"]],[198,-4,[0,"36C8OTS1dA0qevIYuUX6BQ"]]],[3,"48AsoUzdBIpaTw8h1L0fYH",-1,0],[1,0,-106.24000000000001,0]],[20,"ui_to",33554432,1,[[1,-11,[0,"f7NISe7HdAD68SLfhnddy8"],[5,24,24]],[109,0,-12,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294957740],0],[33,32,10,130,3.149999999999997,380,-13,[0,"84HHOo1QBJALrXcgmgoeS/"]]],[3,"d1QhEpQtFB/oCNJ2H0cPU7",1,0],[1,488,0,0]],[83,".key",512,33554432,1,[[1,-14,[0,"c68UOAlNhN171Umca6yVvF"],[5,1260,31.5]],[61,"星系半径",0,20,20,25,3,false,1,-15,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],1],[104,40,3.149999999999997,380,-16,[0,"2bxaOYvqRLMaeaTsW4eoeX"]]],[3,"c6g5KPBGVMNJOZVHNurFoc",1,0]],[52,".value_old",512,33554432,1,[[1,-17,[0,"c68UOAlNhN171Umca6yVvF"],[5,200,31.5]],[16,"5",2,20,20,25,3,false,1,-18,[0,"2frm37uaJHQr0AEEaYyM82"],2],[33,32,10,200,3.149999999999997,380,-19,[0,"adqEY1u+dLt7ziiL5PAp0d"]]],[3,"07HGY4EIpC7bOHWu6P5s8t",1,0],[1,330,0,0]],[52,".unit_old",512,33554432,1,[[1,-20,[0,"c68UOAlNhN171Umca6yVvF"],[5,80,31.5]],[16,"/月",2,20,20,25,3,false,1,-21,[0,"2frm37uaJHQr0AEEaYyM82"],3],[33,32,10,160,3.149999999999997,380,-22,[0,"d9qTJqZk5Nx7sdDH94cqfx"]]],[3,"7fYXHEPWJGAYHp3bhc3vqi",1,0],[1,430,0,0]],[52,".value",512,33554432,1,[[1,-23,[0,"c68UOAlNhN171Umca6yVvF"],[5,200,31.5]],[16,"5",2,20,20,25,3,false,1,-24,[0,"2frm37uaJHQr0AEEaYyM82"],4],[33,32,10,40,3.149999999999997,380,-25,[0,"3eevGF/TVJVacBt3eSFZWM"]]],[3,"ceU3gOBlZJmoxNIRj4u/qd",1,0],[1,490,0,0]],[52,".unit",512,33554432,1,[[1,-26,[0,"c68UOAlNhN171Umca6yVvF"],[5,80,31.5]],[16,"/月",2,20,20,25,3,false,1,-27,[0,"2frm37uaJHQr0AEEaYyM82"],5],[44,32,10,3.149999999999997,380,-28,[0,"0e7Z9msBZHo5yPm57BkPt0"]]],[3,"86gvTKVSdON7n9kSopMgVC",1,0],[1,590,0,0]]],0,[0,8,1,0,0,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,-5,6,0,-6,7,0,0,2,0,0,2,0,0,2,0,0,3,0,0,3,0,0,3,0,0,4,0,0,4,0,0,4,0,0,5,0,0,5,0,0,5,0,0,6,0,0,6,0,0,6,0,0,7,0,0,7,0,0,7,0,16,1,28],[0,0,0,0,0,0],[1,2,2,2,2,2],[41,0,0,0,0,0]],[[[49,"galaxylastName",["尔卡星","洛斯星","尔法星","利亚星","斯诺星","希欧星","古尔星","特瑞星","伦森星","罗特星","卡蛇星","杜萨星","海兹星","铂尔星","尔纳星","斯若星","瑞斯星","索尔星","德尔星","希尔星","希亚星","里奥星"]]],0,0,[],[],[]],[[{"name":"default_scrollbar","rect":{"x":0,"y":0,"width":30,"height":15},"offset":{"x":0,"y":0},"originalSize":{"width":30,"height":15},"rotated":false,"capInsets":[0,0,0,0],"texture":"0da256a2-21f6-481b-90b6-d3643a09179b@6c48a","packable":true}],[5],0,[0],[13],[42]],[[[49,"dataTechTree",[[{"name":"能源产能提升","description":"噢! 瞧瞧! 我的天哪!\n你什么时候拥有了这么出色的汽修天赋?\n你的天赋完美升级了你的能源开采机器，\n能源的开采效率更快了！\n效果：所有能源矿井的开采效率×1.45","cost":350},{"name":"能源矿井拓展","description":"想要开发大型行星?\n先看看你的汽修水平吧?\n不错，现在你的汽修水平让你的能源开采机器获得了新结构,能够对大型行星进行开发！增加可接入式能源开采单元，可以提高能源开采设施的产能，允许提高能源矿井等级至 II 级。\n建立高等级的能源开采设施，可以允许在能源采集难度更大的星球进行资源开采工作。","cost":750},{"name":"节能技术","description":"促进传统产业转型升级，促进制造业高端化、智能化、绿色化、服务化，构建绿色制造体系，推进产品全生命周期绿色管理，不断优化工业产品结构。\n------“十三五”节能减排综合工作方案\n新型科技对你的矿物开采机器进行了优化，能够减少能耗啦!\n效果：全体矿物开采机器每次开采所消耗的能源×0.75","cost":1000},{"name":"戴森球计划","description":"还有什么比直接利用\n恒星的核聚变能源\n更令人激动呢？","cost":2500},{"name":"可持续发展","description":"怪事，手上的这份《科技树加点指南》为什么格外不一样，多了一张可持续发展规划图，ohhhhhh!\n效果：矿物开采使星球资源不容易枯竭","cost":2500},{"name":"能源产能革新","description":"你的能源开采机器进一步得到了锤炼，开采的效率显著提升啦!\n效果：所有能源矿井的开采效率×2.05","cost":700},{"name":"能源矿井阵列","description":"你的能源开采机器有了自己的思维，能够自动在巨型行星上开采能源进行结构的优化，能够对巨型行星进行开发！科学家设计出来更大规模的能源采集设施，可以继续提高能源开采设备的规模，提高能源矿井等级至 III 级。\n建立高等级的能源开采设施，可以允许在能源采集难度更大的星球进行资源开采工作。","cost":1500},{"name":"节能转运","description":"面对艰难的跨星系运输，经过科学改造，转运资源的消耗降低了！\n效果：在不同星系之间进行的资源运输所消耗的全体资源×0.80","cost":2000}],[{"name":"晶钢产能提升","description":"你的晶体钢开采机器得到了锤炼，开采的效率更快了\n效果：所有晶体钢矿井开采效率×1.55","cost":500},{"name":"晶钢矿井拓展","description":"还不明白吗? 但凡半径大点的行星就得用这个挖矿!”\n           -------某不知名晶钢矿井II先生","cost":700},{"name":"便携拆卸技术","description":"工程设施便携式拆卸迁移技术，拥有宇宙摸鱼技术协会认证，采用框架解构策略迁移工程设施。\n据测算，相对常规工程设施迁移解决方案，该技术方案可以有效利用该建筑建造成本的80%。\n此外该方案固有支持设施非整体性迁移，兼具灵活性，有效降低工程设施星际迁移成本，提高摸鱼效率，是您最好的选择！","cost":900},{"name":"基地结构优化","description":"在星际漂泊最怕的是家被砸没了，改进了星际探索时的基地结构，更加坚固耐砸了!\n效果：可以进行二级基地的升级，基地升级后能够增加矿物的仓储量","cost":1200},{"name":"基地框架更新","description":"虽然优化了基地的结构，但是还是被陨石砸坏了，经过漫长的摸鱼，终于对基地的框架再次进行了更新，更加结实耐砸了!\n效果：可以进行三级基地的升级，三级基地增加了矿物的仓储量","cost":1500},{"name":"晶钢产能革新","description":"坏起来了，《科技树加点指南》有这项吗?\n算了，先点了再说!\n效果：所有晶钢矿井的开采效率×2.35","cost":1000},{"name":"晶钢矿井阵列","description":"没有超级挖矿机，就没有钢产量”\n效果：晶钢矿井III；能够开采难度为高的巨型行星的晶钢矿脉","cost":1200},{"name":"节能转运","description":"面对艰难的跨星系运输，经过科学改造，转运资源的消耗降低了！\n效果：在不同星系之间进行的资源运输所消耗的全体资源×0.75","cost":3000}],[{"name":"芯髓产能提升","description":"你的芯片髓核开采机器得到了锤炼，开采的效率更快了!\n效果：芯片髓核矿井的开采效率×1.65","cost":750},{"name":"芯髓矿井拓展","description":"在更多的星球上挖掘这种硬通货！\n建立高等级的芯髓开采设施，可以允许在芯髓采集难度更大的星球进行资源开采工作。","cost":1000},{"name":"维修保险","description":"虽然设施经常被陨石砸坏，但是还是要努力在下次被砸之前维修成功。\n效果：损坏设施的维修花费×0.80","cost":1500},{"name":"行星防御网络","description":"为了生存在太空的艰难被砸环境和避免突发的星际土匪抢劫意外，行星防御网络准备就绪。\n效果：能够建造行星防御网络","cost":1800},{"name":"探索消耗降低","description":"花更少的钱，探索更远的星系，是我们摸鱼的另一大宗旨，总之少花一点是一点。\n效果：进行星系探索所花费的矿物×0.80","cost":2500},{"name":"芯髓产能革新","description":"这本《科技树加点指南》怎么有这么多效率提升小技巧? 每天一个效率提升小技巧，摸鱼的时间就更多了!\n效果：所有芯片髓核矿井的开采效率×2.5","cost":1500},{"name":"芯髓矿井阵列","description":"你的芯片髓核开采机器有了自己的思维，能够自动为自己的结构更进行优化啦！\n“我要贯穿大型行星的星核，拿下它的芯髓！”\n         ------芯片髓核矿井III\n建立高等级的芯髓开采设施，可以允许在芯髓采集难度更大的星球进行资源开采工作。","cost":1400},{"name":"节能转运","description":"面对艰难的跨星系运输，经过科学改造，转运资源的消耗降低了！\n效果：在不同星系之间进行的资源运输所消耗的全体资源×0.70","cost":4000}]]]],0,0,[],[],[]],[[[123,".bin",81448,3337052603,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":69160,"length":12288,"count":6144,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":69160,"count":1235,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]]],0,0,[],[],[]],[[{"name":"default_toggle_checkmark","rect":{"x":4,"y":5,"width":20,"height":18},"offset":{"x":0,"y":0},"originalSize":{"width":28,"height":28},"rotated":false,"capInsets":[0,0,0,0],"texture":"158e7e52-3220-4cd7-9694-713e0e6e8278@6c48a","packable":true}],[5],0,[0],[13],[43]],[[[124,"builtin-standard",[{"hash":442396670,"name":"builtin-standard|standard-vs|standard-fs","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nlayout(location = 0) out float v_fog_factor;\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(location = 0) in float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n  float CCGetLinearDepth (vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    float dist = length(viewStartPos.xyz);\n    return cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block1 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block2 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block3 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n    } else {\n      block0 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n      block1 = step(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x, offsetDepth);\n      block2 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x, offsetDepth);\n      block3 = step(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x, offsetDepth);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float bias = cc_shadowWHPBInfo.w;\n    float offsetDepth = clipPos.z - bias;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block1 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block2 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block3 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block4 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block5 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block6 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block7 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block8 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n    } else {\n      block0 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x, offsetDepth);\n      block1 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x, offsetDepth);\n      block2 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x, offsetDepth);\n      block3 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x, offsetDepth);\n      block4 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n      block5 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x, offsetDepth);\n      block6 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x, offsetDepth);\n      block7 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x, offsetDepth);\n      block8 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x, offsetDepth);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 9.0;\n  }\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.001);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.001);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowWHPBInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      float cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\n      vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n      vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n      if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorSoft2X(pos);\n      else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorSoft(pos);\n      else shadowAttenuation = CCGetShadowFactorHard(pos);\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + dirlightContrib.rgb * (1.0 - cc_shadowColor.a);\n      if (cc_shadowNFLSInfo.w > 0.000001) {\n        dirlightContrib.rgb = shadowColor.rgb * shadowAttenuation + dirlightContrib.rgb * (1.0 - shadowAttenuation);\n      } else {\n        dirlightContrib.rgb = shadowColor.rgb * shadowAttenuation * NL + dirlightContrib.rgb * (1.0 - shadowAttenuation * NL);\n      }\n    }\n  #endif\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 9) uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z + 0.001;\n            float shadowAttenuation = 0.0;\n            float cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\n            vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n            vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n            if (pcf > 2.0) shadowAttenuation = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\n            else if (pcf > 1.0) shadowAttenuation = CCGetSpotLightShadowFactorSoft(pos, s.position);\n            else shadowAttenuation = CCGetSpotLightShadowFactorHard(pos, s.position);\n            lightColor *= 1.0 - shadowAttenuation;\n          }\n        }\n      #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 0\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  float CCGetLinearDepth (vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    float dist = length(viewStartPos.xyz);\n    return cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block1 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block2 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block3 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n    } else {\n      block0 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n      block1 = step(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x, offsetDepth);\n      block2 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x, offsetDepth);\n      block3 = step(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x, offsetDepth);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float bias = cc_shadowWHPBInfo.w;\n    float offsetDepth = clipPos.z - bias;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block1 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block2 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block3 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block4 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block5 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block6 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block7 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block8 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n    } else {\n      block0 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x, offsetDepth);\n      block1 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x, offsetDepth);\n      block2 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x, offsetDepth);\n      block3 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x, offsetDepth);\n      block4 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n      block5 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x, offsetDepth);\n      block6 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x, offsetDepth);\n      block7 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x, offsetDepth);\n      block8 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x, offsetDepth);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 9.0;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.001);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.001);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowWHPBInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      float cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\n      vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n      vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n      if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorSoft2X(pos);\n      else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorSoft(pos);\n      else shadowAttenuation = CCGetShadowFactorHard(pos);\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + dirlightContrib.rgb * (1.0 - cc_shadowColor.a);\n      if (cc_shadowNFLSInfo.w > 0.000001) {\n        dirlightContrib.rgb = shadowColor.rgb * shadowAttenuation + dirlightContrib.rgb * (1.0 - shadowAttenuation);\n      } else {\n        dirlightContrib.rgb = shadowColor.rgb * shadowAttenuation * NL + dirlightContrib.rgb * (1.0 - shadowAttenuation * NL);\n      }\n    }\n  #endif\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z + 0.001;\n            float shadowAttenuation = 0.0;\n            float cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\n            vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n            vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n            if (pcf > 2.0) shadowAttenuation = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\n            else if (pcf > 1.0) shadowAttenuation = CCGetSpotLightShadowFactorSoft(pos, s.position);\n            else shadowAttenuation = CCGetSpotLightShadowFactorHard(pos, s.position);\n            lightColor *= 1.0 - shadowAttenuation;\n          }\n        }\n      #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 0\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\n      uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nvarying float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\n  uniform lowp vec4 cc_shadowColor;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  float CCGetLinearDepth (vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    float dist = length(viewStartPos.xyz);\n    return cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block1 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block2 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block3 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n    } else {\n      block0 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n      block1 = step(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x, offsetDepth);\n      block2 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x, offsetDepth);\n      block3 = step(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x, offsetDepth);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float bias = cc_shadowWHPBInfo.w;\n    float offsetDepth = clipPos.z - bias;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block1 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block2 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block3 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block4 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block5 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block6 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block7 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      block8 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n    } else {\n      block0 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x, offsetDepth);\n      block1 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x, offsetDepth);\n      block2 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x, offsetDepth);\n      block3 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x, offsetDepth);\n      block4 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n      block5 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x, offsetDepth);\n      block6 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x, offsetDepth);\n      block7 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x, offsetDepth);\n      block8 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x, offsetDepth);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = 0.0;\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      float closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    } else {\n      float closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n      closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n      shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n    }\n    return shadow / 5.0;\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n    float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n    float offsety = 1.0 / cc_shadowWHPBInfo.y;\n    float shadow = 0.0;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    } else {\n      for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n          float closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n          shadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n        }\n      }\n    }\n    return shadow / 9.0;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.001);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.001);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  #if CC_RECEIVE_SHADOW\n    {\n      float pcf = cc_shadowWHPBInfo.z + 0.001;\n      float shadowAttenuation = 0.0;\n      float cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\n      vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n      vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n      if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorSoft2X(pos);\n      else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorSoft(pos);\n      else shadowAttenuation = CCGetShadowFactorHard(pos);\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + dirlightContrib.rgb * (1.0 - cc_shadowColor.a);\n      if (cc_shadowNFLSInfo.w > 0.000001) {\n        dirlightContrib.rgb = shadowColor.rgb * shadowAttenuation + dirlightContrib.rgb * (1.0 - shadowAttenuation);\n      } else {\n        dirlightContrib.rgb = shadowColor.rgb * shadowAttenuation * NL + dirlightContrib.rgb * (1.0 - shadowAttenuation * NL);\n      }\n    }\n  #endif\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z + 0.001;\n            float shadowAttenuation = 0.0;\n            float cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\n            vec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n            vec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\n            if (pcf > 2.0) shadowAttenuation = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\n            else if (pcf > 1.0) shadowAttenuation = CCGetSpotLightShadowFactorSoft(pos, s.position);\n            else shadowAttenuation = CCGetSpotLightShadowFactorHard(pos, s.position);\n            lightColor *= 1.0 - shadowAttenuation;\n          }\n        }\n      #endif\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 0\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(s.position, s.roughness);\n    gl_FragData[2] = vec4(s.normal, s.metallic);\n    gl_FragData[3] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":216,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":59}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","type":14,"count":1,"stageFlags":1,"format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":1,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":1,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":1,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":1,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}]},{"hash":826679743,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      vec4 viewStartPos = cc_matLightView * v_worldPos;\n      float dist = length(viewStartPos.xyz);\n      float linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n      return vec4(linearDepth, 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      vec4 viewStartPos = cc_matLightView * v_worldPos;\n      float dist = length(viewStartPos.xyz);\n      float linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n      return vec4(linearDepth, 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      vec4 viewStartPos = cc_matLightView * v_worldPos;\n      float dist = length(viewStartPos.xyz);\n      float linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n      return vec4(linearDepth, 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":179,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":22}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_texCoord1","type":14,"count":1,"stageFlags":1,"format":21,"location":13,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":1,"location":3,"defines":[]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}},"migrations":{"properties":{"pbrParams":{"removeImmediately":true}}}},{"phase":"deferred","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","blendState":{"targets":[{"blend":false},{"blend":false},{"blend":false},{"blend":false}]},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[{"name":"UIAtlas","spriteFrames":["Button","1e386ee6-6018-4cef-8635-a2a08f77366d@80d30","ButtonHover","1e386ee6-6018-4cef-8635-a2a08f77366d@381f0","ButtonPress","1e386ee6-6018-4cef-8635-a2a08f77366d@e21ab","CheckBox","1e386ee6-6018-4cef-8635-a2a08f77366d@73bf2","ContentFrame","1e386ee6-6018-4cef-8635-a2a08f77366d@09edf","NoticeBoard","1e386ee6-6018-4cef-8635-a2a08f77366d@05ae1","button_disabled","1e386ee6-6018-4cef-8635-a2a08f77366d@c2823","choice_bg","1e386ee6-6018-4cef-8635-a2a08f77366d@e0566","choice_hover","1e386ee6-6018-4cef-8635-a2a08f77366d@2e257","dialog","1e386ee6-6018-4cef-8635-a2a08f77366d@9883b","rect","1e386ee6-6018-4cef-8635-a2a08f77366d@2b5a1","rect_disabled","1e386ee6-6018-4cef-8635-a2a08f77366d@2dc0c","rect_hover","1e386ee6-6018-4cef-8635-a2a08f77366d@a7d85","rect_pressed","1e386ee6-6018-4cef-8635-a2a08f77366d@c3f5e","setting_board","1e386ee6-6018-4cef-8635-a2a08f77366d@1aaca"]}],[19],0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"20835ba4-6145-4fbc-a58a-051ce700aa3e@6c48a","packable":true}],[5],0,[0],[13],[44]],[[{"name":"default_progressbar","rect":{"x":0,"y":0,"width":30,"height":15},"offset":{"x":0,"y":0},"originalSize":{"width":30,"height":15},"rotated":false,"capInsets":[10,4,10,4],"texture":"24a704da-2867-446d-8d1a-5e920c75e09d@6c48a","packable":true}],[5],0,[0],[13],[45]],[[{"name":"default_scrollbar_bg","rect":{"x":0,"y":0,"width":30,"height":15},"offset":{"x":0,"y":0},"originalSize":{"width":30,"height":15},"rotated":false,"capInsets":[10,4,10,4],"texture":"28765e2f-040a-4c65-8e8c-f9d0bb79d863@6c48a","packable":true}],[5],0,[0],[13],[46]],[[[27,"RichTextTip"],[149,"RichTextTip",33554432,[[226,"idk",1,false,-2,[0,"38SyWCSTJPXqCQ3jwcbUzC"],0],[173,17,0.14,false,-3,[0,"e09OiaiEBCUYnXpEBM1Rq2"]],[8,-4,[0,"291/Er3hxIv5g8ZnnphRyr"]],[1,-5,[0,"79m55P5SxGVZEzqu/0MX6Z"],[5,58.01,50.4]]],[3,"20/IVxxvhI5pgb6EdANaNl",-1,0],[1,0,251.28000000000003,0]]],0,[0,8,1,0,0,1,0,0,1,0,0,1,0,0,1,0,16,1,5],[0],[2],[0]],[[[231,"0",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_ALBEDO_MAP":true,"USE_ALPHA_TEST":true},{},{},{}],[[[{"alphaThreshold":0.304,"roughness":0,"metallic":0},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[19,17],[47,15]],[[[49,"galaxyName",["凝","蔚","梅","碧","光","北","璟","塞","阿","克","赫","尼","米","可","索","普","漫","天","魔","墨","优","海","吴","拉","菲","灵","提","羽","凌","奥","巴","莱恩","幻","帕","影","哈","比","科","乌"]]],0,0,[],[],[]],[[[49,"dataSystem",{"se":{"decision":"002-System02","cursor":"001-System01","cancel":"003-System03","invalid":"004-System04","equip":"005-System05","buy":"006-System06","save":"007-System07","load":"008-System08","energy":"011-System11"},"resName":["能源","晶钢","芯髓"],"facilities":[{"name":"基地","cost":[[0,0,0],[5000,5000,0],[20000,10000,0]],"capacity":[[10000,10000,10000],[22000,22000,22000],[34000,34000,34000]]},{"name":"能源矿井","cost":[[0,0,0],[500,500,0],[2000,1000,0]],"capacity":[[5000,0,0]]},{"name":"红色咸鱼矿矿井","cost":[[5000,0,0],[10000,5000,0],[15000,10000,0]],"capacity":[[0,5000,0]]},{"name":"绿色咸鱼矿矿井","cost":[[5000,5000,0],[15000,9500,5000],[25000,14000,15000]],"capacity":[[0,0,5000]]},{"name":"行星防御系统","cost":[[10000,10000,10000],[20000,20000,20000],[30000,30000,30000]]}]}]],0,0,[],[],[]],[[[27,"NodeDialogue"],[53,"NodeDialogue",33554432,[-9,-10],[[110,1,0,-2,[0,"3dzKo7VZBKAKkOgcq0n/sf"],0,1,2],[234,-5,[0,"0amNdNsR1J3qP55x4bqmoY"],[-3,-4]],[235,2,8,30,-5,-6,[0,"2e+jUPJKVBbZYPovGudmL0"]],[8,-7,[0,"06ByfJLQNOW6NcG1tF0XGF"]],[2,-8,[0,"b9xn6MoDxBXJEoh+4XdsXd"],[5,300,175],[0,0.16,0]]],[3,"d11/0EHtRP6bkEH9QNcB4Q",-1,0]],[65,"label",33554432,1,[[-11,[129,1,-12,[0,"94cBY8QtdAV7JUOsRqt5X7"]],[58,40,8,8,200,-13,[0,"5djSjADj9JioZ1pjL0se/B"]],[8,-14,[0,"55SS9+lXdIcbdIfpvMbwFz"]],[2,-15,[0,"6evqL23wlIEoMR4UZx07eP"],[5,284,108.5],[0,0.5,0]]],1,4,4,4,4],[3,"d5buNG93pHYo/Q0ONBLtD9",1,0],[1,102,58.5,0]],[65,"label copy",33554432,1,[[-16,[242,1,-17,[0,"02IJsvV1xEl7ft2OM0lmxj"],[4,4278193448]],[58,40,8,8,200,-18,[0,"f4/0IsgjNFAI4XnE1iZjIi"]],[8,-19,[0,"092DUkmk9IzZpKFJMhIJft"]],[2,-20,[0,"de3k1X3EFIe5rFMmHnbOqm"],[5,284,33.5],[0,0.5,0]]],1,4,4,4,4],[3,"cfexPwdjBFcKj15LN94oKv",1,0],[1,102,30,0]],[203,"大家好呀，我叫马保国。有个小伙子问我发生什么事了，原来是，有两个年轻人，他们不讲武德。",0,0,25,25,25,3,false,0,1,2,[0,"c6IP2TXexIrbtnym3M92zW"]],[204,"(点击继续)",2,0,25,25,25,3,false,0,1,3,[0,"6cDh784mpLJbGMdqDaYyAG"],[4,4278222847]]],0,[0,8,1,0,0,1,0,-1,4,0,-2,5,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,-1,4,0,0,2,0,0,2,0,0,2,0,0,2,0,-1,5,0,0,3,0,0,3,0,0,3,0,0,3,0,16,1,20],[0,0,0,4,4,5,5],[7,1,14,7,2,7,2],[1,48,6,1,0,1,0]],[[[244,"galaxy"],[150,"Canvas",33554432,"eankUkou9LgLpFhzZTp7yb",[-20,-21,-22,-23,-24,-25,-26,-27],[[245,-2,-1],[88,45,-3],[246,-17,[-14,-15,-16],-13,-12,[-10,-11],-9,[-7,-8],-6,-5,[-4],171,172],[7,-18],[11,-19,[5,1280,768]]],[1,640,384,0]],[21,".resource",33554432,[-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50],[[1,-28,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,400,163]],[236,1,3,5,2,4,-29,[0,"eaGEkmlCpANK+GS6CImtZa"],[5,100,32]],[34,40,106,-206,540,768,-30]],[1,0,-275.3,0]],[160,"listBox",33554432,[-59,-60],[[[1,-51,[0,"71kmounFRG/K27WWBbH2RB"],[5,210,32]],[8,-52,[0,"ee9eXX+ClCDZa1or00eIip"]],-53,[174,32,10,-54],-55,[26,2,-58,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"940d4XZy2ZHpZq0HhvR6iwH","toggleList",-57]],[4,4292269782],-56,142,143,144,145]],4,4,1,4,1,4],[1,155,-75.12,0]],[161,"Scene_Transfer",33554432,1,[-65,-66],[[[19,45,50,50,-61],[7,-62],[11,-63,[5,1280,768]],-64],4,4,4,1]],[21,"Layout",33554432,[-72,-73,-74,-75,-76,-77,3,-78,-79],[[2,-67,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,668],[0,0.5,1]],[7,-68],[30,37,888,440,80,20,400,768,-69],[132,-70],[39,1,0,-71,156]],[1,-70,-80,0]],[64,"Layout",33554432,[-85,-86,-87,-88,-89,2,-90,-91],[[2,-80,[0,"71kmounFRG/K27WWBbH2RB"],[5,400,668],[0,0.5,1]],[7,-81],[19,45,540,768,-82],[237,2,10,-83],[39,1,0,-84,119]]],[151,"Operation",false,33554432,[-96,-97,-98,-99,-100,-101,-102],[[19,45,50,50,-92],[7,-93],[11,-94,[5,1280,768]],[80,-95]]],[86,"UpgradeBoard",false,33554432,1,[5],[[[2,-103,[0,"71kmounFRG/K27WWBbH2RB"],[5,1280,768],[0,0.5,1]],[7,-104],[19,45,600,768,-105],[51,-106],[247,-108,[[10,"53d46riXTpJo6q8nepchkB3","close",-107]]],-109],4,4,4,4,4,1],[1,0,384,0]],[64,"Layout",33554432,[-113,-114,-115,-116,-117,-118,-119,-120],[[2,-110,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,668],[0,0.5,1]],[7,-111],[19,37,600,768,-112]]],[21,"TreeBoard",33554432,[-125,-126,-127,-128,-129,-130],[[2,-121,[0,"71kmounFRG/K27WWBbH2RB"],[5,384,668],[0,0.5,1]],[7,-122],[175,45,0.7,80,20,false,400,768,-123],[39,1,0,-124,128]],[1,448,304,0]],[84,"Scene_Planet",false,33554432,1,[-137,-138,7,-139],[[19,45,50,50,-131],[7,-132],[11,-133,[5,1280,768]],[256,-135,[7,-134]],[248,false,-136,[[10,"472b4yu8a9PjKp5Zk4EdQK+","callBlank",1]]]]],[54,[24,"dfsCeqolZPwK0P5GVcIoMY",-153,[38,"0c36qi1E5JqLRjiJOPsa5D",[[15,".0",["_name"],-140],[9,["_lpos"],-141,[1,0,0,0]],[9,["_lrot"],-142,[3,0,0,0,1]],[14,["_prefab","root"],-144,-143],[14,["editingDidEnded","0","target"],-145,4],[15,"9d3a1sSv+xAC6neeQPJ008d",["editingDidEnded","0","_componentId"],-146],[15,"checkTransfer",["editingDidEnded","0","handler"],-147],[17,["_prefab","root"],[5,["02KXwSs0NL1YlzUhyrWl3E"]],-148],[17,["_prefab","root"],[5,["4c0DhYTYZF06HhZcGRu0sa"]],-149],[17,["_prefab","root"],[5,["f4AMWrbKZGFLDHBbYNgCis"]],-150],[17,["_prefab","root"],[5,["06j2lE/NhNlbc9+gtWSnME"]],-151],[15,33554432,["_layer"],-152]]],45]],[84,"Scene_Tree",false,33554432,1,[-160,10,-161],[[19,45,50,50,-154],[7,-155],[11,-156,[5,1280,768]],[259,-159,[130,131],-158,10,-157]]],[162,"EmergencyBoard",false,33554432,1,[-168],[[[1,-162,[0,"71kmounFRG/K27WWBbH2RB"],[5,1280,768]],[7,-163],[19,45,600,768,-164],[51,-165],[132,-166],-167],4,4,4,4,4,1]],[21,"Button",33554432,[-173],[[1,-169,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[13,1,0,-170,[0,"77BcV1zfNHo4LI4KRqZupe"],65],[130,false,2,-172,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"9d3a1sSv+xAC6neeQPJ008d","callExplore",4]],[4,4292269782],-171,66,67,68,69]],[1,0,-605.56,0]],[21,".0",33554432,[-180,-181,-182,-183],[[2,-174,[0,"f7NISe7HdAD68SLfhnddy8"],[5,390,128],[0,0.5,1]],[13,1,0,-175,[0,"e71ctEmpxFC4KlSYRZNz/a"],36],[260,1,false,-178,-177,[[10,"9d3a1sSv+xAC6neeQPJ008d","selectOther",4]],-176,37],[136,-179]],[1,0,-5,0]],[64,"Layout",33554432,[-187,-188,-189,-190,-191,-192],[[2,-184,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,668],[0,0.5,1]],[7,-185],[19,37,600,768,-186]]],[21,".0",33554432,[-200,-201,-202,-203,-204],[[1,-193,[0,"55pCbtzR5GbojKMArZkfim"],[5,380,80]],[25,0,-194,[0,"20UGQn4U9GUoln0NJQTkbG"],113],[23,40,10,10,252,-195],[265,-199,[-197,-198],[114,115,116,117],-196,118]],[1,0,-40,0]],[6,"Layout",33554432,14,[-209,-210,-211,-212],[[2,-205,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,400],[0,0.5,1]],[7,-206],[30,18,888,440,80,-80,400,768,-207],[39,1,0,-208,170]],[1,0,200,0]],[64,"ExploreBoard",33554432,[17,15],[[2,-213,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,668],[0,0.5,1]],[7,-214],[19,37,600,768,-215],[80,-216],[51,-217]]],[6,"Right",33554432,4,[-222,-223,-224,20],[[2,-218,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,668],[0,0.5,1]],[7,-219],[105,37,20,80,20,600,768,-220],[39,1,0,-221,58]],[1,350,304,0]],[6,"Left",33554432,4,[-229,-230,-231,-232],[[2,-225,[0,"71kmounFRG/K27WWBbH2RB"],[5,420,668],[0,0.5,1]],[7,-226],[105,13,440,80,20,420,768,-227],[39,1,0,-228,38]],[1,-430,304,0]],[32,"DataBoard",33554432,21,[-238,-239],[[2,-233,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,668],[0,0.5,1]],[7,-234],[19,37,600,768,-235],[80,-236],[51,-237]]],[32,"Layout",33554432,23,[-243,-244,-245,-246,-247],[[2,-240,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,668],[0,0.5,1]],[7,-241],[19,37,600,768,-242]]],[32,"TransferBoard",33554432,21,[9,-253],[[2,-248,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,668],[0,0.5,1]],[7,-249],[19,37,600,768,-250],[80,-251],[51,-252]]],[6,".btn_action",33554432,5,[-259],[[1,-254,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[13,1,0,-255,[0,"77BcV1zfNHo4LI4KRqZupe"],146],[26,2,-257,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"53d46riXTpJo6q8nepchkB3","callDecision",8]],[4,4292269782],-256,147,148,149,150],[68,20,20,-100,-258]],[1,-100,-628,0]],[84,"Scene_Title",false,33554432,1,[-263,-264,-265,-266],[[19,45,50,50,-260],[7,-261],[11,-262,[5,1280,768]]]],[55,"Start",false,33554432,27,[-273],[[1,-267,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[7,-268],[13,1,0,-269,[0,"77BcV1zfNHo4LI4KRqZupe"],2],[26,2,-271,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"472b4yu8a9PjKp5Zk4EdQK+","gameStart",1]],[4,4292269782],-270,3,4,5,6],[89,18,364,679.2470000000001,-64,-272]],[1,0,-64,0]],[55,"Exit",false,33554432,27,[-280],[[1,-274,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[7,-275],[13,1,0,-276,[0,"77BcV1zfNHo4LI4KRqZupe"],7],[26,2,-278,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"472b4yu8a9PjKp5Zk4EdQK+","endGame",1]],[4,4292269782],-277,8,9,10,11],[89,18,364,679.2470000000001,-128,-279]],[1,0,-128,0]],[54,[24,"12BtlrGU9Kp6cfll4JHAJN",-291,[38,"63SBZUQGdOO6Bcq7mHRUw8",[[15,"ResourceItem",["_name"],-281],[9,["_lpos"],-282,[1,0,0,0]],[9,["_lrot"],-283,[3,0,0,0,1]],[14,["_prefab","root"],-285,-284],[17,["_prefab","root"],[5,["40h1HypR9MfrBYBZeaAntC"]],-286],[17,["_prefab","root"],[5,["82bxjsN/JG35wDJM4t6xwc"]],-287],[17,["_prefab","root"],[5,["0bdeRZ4rVIoKDYt25r1yoZ"]],-288],[17,["_prefab","root"],[5,["c4gJoKK35Aibf3qSBNEu6L"]],-289],[17,["_prefab","root"],[5,["62MYZ/kLxOxKquvZepfp+t"]],-290]]],14]],[6,"galaxy_panel",33554432,22,[-296,-297,-298],[[2,-292,[0,"f7NISe7HdAD68SLfhnddy8"],[5,390,128],[0,0.5,1]],[13,1,0,-293,[0,"e71ctEmpxFC4KlSYRZNz/a"],29],[136,-294],[249,-295,[[10,"9d3a1sSv+xAC6neeQPJ008d","selectCurrent",4]],30]],[1,-5,-56,0]],[21,".0",33554432,[-301,-302,-303,-304,-305],[[1,-299,[0,"55pCbtzR5GbojKMArZkfim"],[5,252,24]],[137,-300]],[1,0,-12,0]],[21,"ResourceItem",33554432,[-308,-309,-310,-311,-312],[[1,-306,[0,"55pCbtzR5GbojKMArZkfim"],[5,252,24]],[137,-307]],[1,0,-12,0]],[55,"PlanetPanel",false,33554432,11,[6],[[2,-313,[0,"71kmounFRG/K27WWBbH2RB"],[5,400,668],[0,0.5,1]],[7,-314],[176,37,888,80,20,400,768,-315],[51,-316]],[1,440,304,0]],[56,13,[24,"12BtlrGU9Kp6cfll4JHAJN",-328,[134,"8c6HDxjQdOA7WRemVi4TlY",[[138,[null],[5,["12BtlrGU9Kp6cfll4JHAJN"]]]],[[15,"ResourceItem",["_name"],-317],[9,["_lpos"],-318,[1,346,359,0]],[9,["_lrot"],-319,[3,0,0,0,1]],[14,["_prefab","root"],-321,-320],[17,["_prefab","root"],[5,["40h1HypR9MfrBYBZeaAntC"]],-322],[17,["_prefab","root"],[5,["82bxjsN/JG35wDJM4t6xwc"]],-323],[17,["_prefab","root"],[5,["0bdeRZ4rVIoKDYt25r1yoZ"]],-324],[17,["_prefab","root"],[5,["c4gJoKK35Aibf3qSBNEu6L"]],-325],[17,["_prefab","root"],[5,["62MYZ/kLxOxKquvZepfp+t"]],-326],[15,true,["_active"],-327]]],129]],[57,"BackButton",false,33554432,1,[[1,-329,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,64,64]],[7,-330],[13,1,0,-331,[0,"77BcV1zfNHo4LI4KRqZupe"],132],[250,3,0.9,-333,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"472b4yu8a9PjKp5Zk4EdQK+","blockBackByButton",1]],[4,4292269782],-332,133,134,135,136],[45,9,12,12,-334]],[1,-596,340,0]],[152,"GameControl",512,"20myQ0lgVA74QOSBK46NhU",[-341],[[266,"RenderRoot2D",-335],[87,-336,[5,1280,768],[0,0,0]],[88,45,-337],[267,-338,[183,184,185,186,187,188],[189],[190,191,192]],[139,true,false,-339],[139,true,false,-340]]],[268,"galaxy",[1,-346,-347,-348,-349,37],[199,[[81,["listBox"],-342,3,[5,["9bZNvPPMFIrpdEafXalQOl"]]],[63,["toggleButton"],3,[5,["9bZNvPPMFIrpdEafXalQOl"]],3,[5,["77BcV1zfNHo4LI4KRqZupe"]]],[63,["listView"],3,[5,["9bZNvPPMFIrpdEafXalQOl"]],3,[5,["352Lg0yJ1CEY+vaR56K/O8"]]],[63,["optionLabel"],3,[5,["9bZNvPPMFIrpdEafXalQOl"]],3,[5,["2frm37uaJHQr0AEEaYyM82"]]],[81,["optionLabel"],-343,3,[5,["2frm37uaJHQr0AEEaYyM82"]]],[81,["toggleButton"],-344,3,[5,["77BcV1zfNHo4LI4KRqZupe"]]],[81,["listView"],-345,3,[5,["352Lg0yJ1CEY+vaR56K/O8"]]],[63,["_textLabel"],12,[5,["1bCHrwPGZOPrbmPh93kwpe"]],12,[5,["ddIY+NJvlDTIQAg7PLVrGo"]]],[63,["_placeholderLabel"],12,[5,["1bCHrwPGZOPrbmPh93kwpe"]],12,[5,["8fhi7qRLFJbK0abIJuXmCW"]]]]],[269,[270,[4,33536107],[4,4283782655]],[271,0.0035],[272],[273,true,1000]]],[43,"ListView",33554432,11,[-355],[[[1,-350,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,200,52]],[76,1,2,10,10,4,-351,[0,"eaGEkmlCpANK+GS6CImtZa"]],-352,[177,10,-15,218,240,250,-353],[39,1,0,-354,13]],4,4,1,4,4],[1,-540,0,0]],[4,"Pause",33554432,7,[[1,-356,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,64,64]],[7,-357],[13,1,0,-358,[0,"77BcV1zfNHo4LI4KRqZupe"],15],[79,3,0.9,-360,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"472b4yu8a9PjKp5Zk4EdQK+","callPause",1]],[4,4292269782],-359,16],[45,9,12,12,-361]],[1,-596,340,0]],[4,"Option",33554432,7,[[1,-362,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,64,64]],[7,-363],[13,1,0,-364,[0,"77BcV1zfNHo4LI4KRqZupe"],17],[79,3,0.9,-366,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[50,"472b4yu8a9PjKp5Zk4EdQK+","callSetting","1",1]],[4,4292269782],-365,18],[45,9,92,12,-367]],[1,-516,340,0]],[21,"btn1",33554432,[-373],[[1,-368,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[7,-369],[13,1,0,-370,[0,"77BcV1zfNHo4LI4KRqZupe"],19],[26,2,-371,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[50,"472b4yu8a9PjKp5Zk4EdQK+","blockEnterByButton","1",1]],[4,4292269782],15,20,21,22,23],[89,12,364,60,-64,-372]],[1,0,-20,0]],[43,"ScrollView",33554432,22,[-378,-379],[[[1,-374,[0,"71kmounFRG/K27WWBbH2RB"],[5,420,436]],[7,-375],-376,[178,13,60,232,600,768,-377]],4,4,1,4],[1,0,-450,0]],[6,".name",33554432,24,[-386,-387],[[1,-380,[0,"1fhJOVuOVAGYSYZoiE25Uz"],[5,300,50]],[274,"最多六个汉字",6,6,-383,[0,"1bCHrwPGZOPrbmPh93kwpe"],[[10,"9d3a1sSv+xAC6neeQPJ008d","callNameEdit",4]],-382,-381],[35,9,10,170,45,200,-384],[111,1,-385]],[1,-110,-70,0]],[21,".editbox",33554432,[-394,-395],[[1,-388,[0,"1fhJOVuOVAGYSYZoiE25Uz"],[5,60,32]],[13,1,0,-389,[0,"43qH95z3VGeYelCElKd6FW"],63],[275,5,"999",2,3,-392,[0,"1bCHrwPGZOPrbmPh93kwpe"],[[10,"9d3a1sSv+xAC6neeQPJ008d","checkExplore",4]],-391,-390,64],[44,34,28,4,360,-393,[0,"fe7OmRbg1ERKz3p59qXRbR"]]],[1,230,0,0]],[21,"btn2",33554432,[-401],[[1,-396,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[7,-397],[13,1,0,-398,[0,"77BcV1zfNHo4LI4KRqZupe"],70],[26,2,-399,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[50,"472b4yu8a9PjKp5Zk4EdQK+","blockEnterByButton","2",1]],[4,4292269782],15,71,72,73,74],[179,12,364,-64,-400]],[1,0,-80,0]],[6,".name",33554432,6,[-408,-409],[[1,-402,[0,"1fhJOVuOVAGYSYZoiE25Uz"],[5,300,50]],[276,"名字最多八个汉字",6,8,-405,[0,"1bCHrwPGZOPrbmPh93kwpe"],-404,-403],[35,9,10,170,10,200,-406],[111,1,-407]],[1,-40,-35,0]],[43,"ScrollView",33554432,13,[-414,-415],[[[1,-410,[0,"71kmounFRG/K27WWBbH2RB"],[5,812,668]],-411,[180,45,20,0.35,80,20,false,400,768,-412],[13,1,0,-413,[0,"20UGQn4U9GUoln0NJQTkbG"],124]],4,1,4,4],[1,-214,-30,0]],[21,"content",33554432,[-418,-419],[[2,-416,[0,"99yn0cfL9MmZYfJbPmK9qL"],[5,1600,648],[0,0,0]],[181,13,400,-417]],[1,-396,-324,0]],[86,"Layout",false,33554432,3,[-425],[[[2,-420,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,210,32],[0,0.5,1]],[76,1,2,4,4,4,-421,[0,"eaGEkmlCpANK+GS6CImtZa"]],-422,[109,0,-423,[0,"a0vg8iN1VNB6JIrPtDPa0H"],[4,4284371739],141],[182,41,1,false,2,-424,[0,"24DB3MgqpCSIB6Cep5umcL"]]],4,4,1,4,4],[1,0,-20,0]],[6,"btn_cancel",33554432,5,[-431],[[1,-426,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[13,1,0,-427,[0,"77BcV1zfNHo4LI4KRqZupe"],151],[26,2,-429,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"53d46riXTpJo6q8nepchkB3","close",8]],[4,4292269782],-428,152,153,154,155],[68,20,20,100,-430]],[1,100,-628,0]],[57,"Version",false,33554432,27,[[205,"V 0.0.0",2,32,32,32,0,-432,[4,4287430684],0],[183,36,30,20,-433],[93,1,-434,[4,4278242559]],[7,-435],[11,-436,[5,103.41,42.32]]],[1,558.295,-342.84,0]],[6,"btns",33554432,7,[42,46],[[103,-437,[0,0.5,1]],[238,1,2,1,20,true,-438],[106,33,150,-439]],[1,590,234,0]],[163,"Layout",33554432,[16],[[[2,-440,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,390,138],[0,0.5,1]],[76,1,2,5,5,10,-441,[0,"eaGEkmlCpANK+GS6CImtZa"]],-442],4,4,1]],[6,"Button",33554432,23,[-447],[[1,-443,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[13,1,0,-444,[0,"77BcV1zfNHo4LI4KRqZupe"],39],[26,2,-446,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"9d3a1sSv+xAC6neeQPJ008d","callSwitch",4]],[4,4292269782],-445,40,41,42,43]],[1,0,-605.56,0]],[6,"Button",33554432,25,[-452],[[1,-448,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[13,1,0,-449,[0,"77BcV1zfNHo4LI4KRqZupe"],47],[130,false,2,-450,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"9d3a1sSv+xAC6neeQPJ008d","callTransfer",4]],[4,4292269782],15,48,49,50,51],[107,4,42,-451]],[1,0,-606,0]],[43,"ListView",33554432,21,[-457],[[[2,-453,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,110,40],[0,0,0.5]],[239,1,1,10,10,10,20,20,-454,[0,"eaGEkmlCpANK+GS6CImtZa"]],-455,[106,9,8,-456]],4,4,1,4],[1,-270,-28,0]],[6,".0",33554432,57,[-462,-463],[[1,-458,[0,"f7NISe7HdAD68SLfhnddy8"],[5,100,40]],[90,1,0,-459,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4285697814],52],[261,2,-461,[[50,"9d3a1sSv+xAC6neeQPJ008d","blockChangeByList","0",4]],[4,4285697814],[4,4288006738],[4,4287539261],[4,4282796867],-460,53,54,55,56]],[1,60,0,0]],[54,[24,"88uwYuFfFE2KCQtjT7EVQg",-478,[134,"05yCnoFEtAeo3cQpVBmkL/",[[138,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[5,["88uwYuFfFE2KCQtjT7EVQg"]]]],[[15,".0",["_name"],-464],[9,["_lpos"],-465,[1,0,0,0]],[9,["_lrot"],-466,[3,0,0,0,1]],[14,["_prefab","root"],-468,-467],[14,["_prefab","root"],-470,-469],[9,["_lpos"],-471,[1,-260,-2,0]],[14,["_prefab","root"],-473,-472],[9,["_lpos"],-474,[1,120,0,0]],[14,["_prefab","root"],-476,-475],[9,["_lpos"],-477,[1,248,0,0]],[257,40,["_right"],[5,["d4bzFeWTFMupMwEByJ92tO"]]]]],61]],[6,".planetRadius",33554432,6,[-481,-482,-483],[[1,-479,[0,"c68UOAlNhN171Umca6yVvF"],[5,380,32]],[35,41,10,10,92,380,-480]],[1,0,-108,0]],[6,".orbitRadius",33554432,6,[-486,-487,-488],[[1,-484,[0,"c68UOAlNhN171Umca6yVvF"],[5,380,32]],[35,41,10,10,124,380,-485]],[1,0,-140,0]],[153,".btns",18,[-492,-493],[[87,-489,[5,68,32],[0,1,0.5]],[184,33,6,6,-10,100,-490],[240,1,4,1,-491]],[1,184,18,0]],[6,".layout",33554432,18,[-497],[[1,-494,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,360,32]],[62,2,1,20,-495,[0,"eaGEkmlCpANK+GS6CImtZa"]],[30,44,10,10,24,10,100,32,-496]],[1,0,-14,0]],[43,"scrollBar",33554432,48,[-502],[[[2,-498,[0,"17lQPXOPpO0b6Z/3qQRAz3"],[5,812,10],[0,1,0.5]],[90,1,0,-499,[0,"9dLJe/n0BKVoGauB1wT/Tc"],[4,16777215],120],[108,44,12,250,1,-500,[0,"88/VBmjEBOMLWb2cOiN0kU"]],-501],4,4,4,1],[1,406,-329,0]],[54,[24,"88uwYuFfFE2KCQtjT7EVQg",-517,[38,"cc74kqrA5IKpJS2XKEUta3",[[15,"demandItem",["_name"],-503],[9,["_lpos"],-504,[1,0,0,0]],[9,["_lrot"],-505,[3,0,0,0,1]],[14,["_prefab","root"],-507,-506],[14,["_prefab","root"],-509,-508],[9,["_lpos"],-510,[1,-182,-2,0]],[14,["_prefab","root"],-512,-511],[9,["_lpos"],-513,[1,42,0,0]],[14,["_prefab","root"],-515,-514],[9,["_lpos"],-516,[1,170,0,0]]]],126]],[86,"Button",false,33554432,10,[-522],[[[1,-518,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[13,1,0,-519,[0,"77BcV1zfNHo4LI4KRqZupe"],127],-520,[107,4,30,-521]],4,4,1,4],[1,0,-618,0]],[6,".btn_action",33554432,19,[-527],[[1,-523,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[13,1,0,-524,[0,"77BcV1zfNHo4LI4KRqZupe"],160],[26,2,-525,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"5be8fkH4/pByLwK+DfEAvdQ","close",14]],[4,4292269782],26,161,162,163,164],[68,20,20,-100,-526]],[1,-100,-360,0]],[6,".btn_cancel",33554432,19,[-532],[[1,-528,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,100,40]],[13,1,0,-529,[0,"77BcV1zfNHo4LI4KRqZupe"],165],[26,2,-530,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"5be8fkH4/pByLwK+DfEAvdQ","close",14]],[4,4292269782],26,166,167,168,169],[68,20,20,100,-531]],[1,100,-360,0]],[5,["a4Lm6oRZ9O5piArwFkZGxG"]],[55,"Loading",false,2,37,[-537],[[200,0,-533,[4,4280701512],181,182],[88,45,-534],[7,-535],[11,-536,[5,1280,768]]],[1,640,384,0]],[57,"Title",false,33554432,27,[[1,-538,[0,"c68UOAlNhN171Umca6yVvF"],[5,492,132.95999999999998]],[206,"星际摸鱼王",96,96,96,false,1,-539,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4293360892],1],[243,-540,[4,4287758435]],[278,4,-541,[4,4278255615],[0,0,0]]],[1,0,120,0]],[32,".0",33554432,39,[-545,-546],[[1,-542,[0,"f7NISe7HdAD68SLfhnddy8"],[5,180,32]],[262,false,-544,[[10,"472b4yu8a9PjKp5Zk4EdQK+","choosePlanet",1]],-543,12]]],[55,"Resource",false,33554432,11,[30],[[1,-547,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,180,50]],[77,1,1,40,true,-548,[0,"eaGEkmlCpANK+GS6CImtZa"]],[185,17,0.263034375,132,20,false,400,768,-549]],[1,0,359,0]],[6,".resource",33554432,31,[32],[[2,-550,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,252,24],[0,0.5,1]],[92,1,2,4,-551,[0,"eaGEkmlCpANK+GS6CImtZa"]],[46,33,10,37,-552]],[1,59,-37,0]],[43,"scrollBar",33554432,43,[-556],[[[2,-553,[0,"17lQPXOPpO0b6Z/3qQRAz3"],[5,12,436],[0,1,0.5]],[186,37,250,1,-554,[0,"88/VBmjEBOMLWb2cOiN0kU"]],-555],4,4,1],[1,210,0,0]],[6,"view",33554432,43,[54],[[2,-557,[0,"adVJjE6iNG9YcIKwDKe/zq"],[5,390,436],[0,0.5,1]],[133,-558,[0,"4eIg29oQZFVLk+NZnwDdlk"]],[187,45,10,20,240,250,-559]],[1,-5,218,0]],[6,".resource",33554432,16,[33],[[2,-560,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,252,24],[0,0.5,1]],[92,1,2,4,-561,[0,"eaGEkmlCpANK+GS6CImtZa"]],[46,33,10,37,-562]],[1,59,-37,0]],[6,".from_storage",33554432,9,[-566],[[1,-563,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,520,32]],[77,2,1,20,true,-564,[0,"eaGEkmlCpANK+GS6CImtZa"]],[30,41,10,10,108,10,100,32,-565]],[1,0,-124,0]],[56,78,[24,"65oRw/zGhLMrepg83LtCoA",-576,[38,"aaao1nle9DQ6MHK5Jnn6Qn",[[15,".0",["_name"],-567],[9,["_lpos"],-568,[1,0,0,0]],[9,["_lrot"],-569,[3,0,0,0,1]],[14,["_prefab","root"],-571,-570],[14,["_prefab","root"],-573,-572],[9,["_lpos"],-574,[1,-248,0,0]],[17,["_prefab","root"],[5,["5f7f/3UudCNb7Y46M+/V3f"]],-575]]],44]],[6,".editnum",33554432,9,[12],[[1,-577,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,520,32]],[77,2,1,20,true,-578,[0,"eaGEkmlCpANK+GS6CImtZa"]],[30,41,10,10,284,10,100,32,-579]],[1,0,-300,0]],[5,["dfsCeqolZPwK0P5GVcIoMY"]],[6,".to_storage",33554432,9,[-583],[[1,-580,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,520,32]],[77,2,1,20,true,-581,[0,"eaGEkmlCpANK+GS6CImtZa"]],[30,44,10,10,24,200,100,32,-582]],[1,0,-452,0]],[56,82,[24,"65oRw/zGhLMrepg83LtCoA",-594,[38,"5euP3SNdxOTJd3jH1DiapK",[[15,".0",["_name"],-584],[9,["_lpos"],-585,[1,0,0,0]],[9,["_lrot"],-586,[3,0,0,0,1]],[14,["_prefab","root"],-588,-587],[14,["_prefab","root"],-590,-589],[9,["_lpos"],-591,[1,-248,0,0]],[17,["_prefab","root"],[5,["5f7f/3UudCNb7Y46M+/V3f"]],-592],[15,33554432,["_layer"],-593]]],46]],[5,["65oRw/zGhLMrepg83LtCoA"]],[6,".from_storage",33554432,17,[-598],[[1,-595,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,520,32]],[62,2,1,20,-596,[0,"eaGEkmlCpANK+GS6CImtZa"]],[30,41,10,10,108,10,100,32,-597]],[1,0,-124,0]],[56,85,[24,"65oRw/zGhLMrepg83LtCoA",-609,[38,"93ZgbSbAFGbq8hHZosYpo6",[[15,".0",["_name"],-599],[9,["_lpos"],-600,[1,0,0,0]],[9,["_lrot"],-601,[3,0,0,0,1]],[14,["_prefab","root"],-603,-602],[14,["_prefab","root"],-605,-604],[9,["_lpos"],-606,[1,-248,0,0]],[17,["_prefab","root"],[5,["5f7f/3UudCNb7Y46M+/V3f"]],-607],[15,33554432,["_layer"],-608]]],60]],[5,["65oRw/zGhLMrepg83LtCoA"]],[6,".condition",33554432,17,[59],[[1,-610,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,540,180]],[62,2,2,20,-611,[0,"eaGEkmlCpANK+GS6CImtZa"]],[34,44,24,100,100,32,-612]],[1,0,-478,0]],[6,".position",33554432,17,[-616],[[1,-613,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,520,32]],[62,2,1,20,-614,[0,"eaGEkmlCpANK+GS6CImtZa"]],[188,42,10,10,318,10,60,100,32,-615]],[1,0,-274,0]],[6,".kind",33554432,6,[-619,-620],[[1,-617,[0,"c68UOAlNhN171Umca6yVvF"],[5,380,32]],[35,41,10,10,60,380,-618]],[1,0,-76,0]],[6,".layout",33554432,6,[18],[[2,-621,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,400,80],[0,0.5,1]],[92,1,2,4,-622,[0,"eaGEkmlCpANK+GS6CImtZa"]],[189,40,365.62,252,-623]],[1,0,-397.12,0]],[29,".down",33554432,62,[[[1,-624,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,32,32]],-625,[79,3,0.9,-627,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[50,"472b4yu8a9PjKp5Zk4EdQK+","callFacility","degrade",1]],[4,4292269782],-626,107]],4,1,4],[1,-16,0,0]],[29,".up",33554432,62,[[[1,-628,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,32,32]],-629,[79,3,0.9,-631,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"472b4yu8a9PjKp5Zk4EdQK+","callFacility",1]],[4,4292269782],-630,108]],4,1,4],[1,-52,0,0]],[56,63,[24,"65oRw/zGhLMrepg83LtCoA",-642,[38,"d47H3JqRNK95GuEvioz5MW",[[15,".0",["_name"],-632],[9,["_lpos"],-633,[1,0,0,0]],[9,["_lrot"],-634,[3,0,0,0,1]],[14,["_prefab","root"],-636,-635],[14,["_prefab","root"],-638,-637],[9,["_lpos"],-639,[1,-168,0,0]],[17,["_prefab","root"],[5,["5f7f/3UudCNb7Y46M+/V3f"]],-640],[15,33554432,["_layer"],-641]]],111]],[5,["65oRw/zGhLMrepg83LtCoA"]],[32,"view",33554432,48,[49],[[1,-643,[0,"adVJjE6iNG9YcIKwDKe/zq"],[5,792,648]],[133,-644,[0,"4eIg29oQZFVLk+NZnwDdlk"]],[30,45,10,10,10,10,240,250,-645]]],[32,"buttons",33554432,49,[-649],[[87,-646,[5,0,0],[0,0,0]],[279,true,-647,[[94]]],[280,5,-648]]],[6,"TechButton",33554432,97,[-654],[[1,-650,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,160,40]],[13,1,0,-651,[0,"77BcV1zfNHo4LI4KRqZupe"],121],[263,1,1.1,false,-653,[0,"88pHvPHqNI3ax2IGv2QYp8"],[[10,"cc32ae4iWRCbpNIabux8iPV","checkSelect",13]],-652,122]],[1,101.7,628,0]],[6,".condition",33554432,10,[65],[[1,-655,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,384,180]],[62,2,2,20,-656,[0,"eaGEkmlCpANK+GS6CImtZa"]],[34,44,24,100,100,32,-657]],[1,0,-478,0]],[5,["12BtlrGU9Kp6cfll4JHAJN"]],[29,".effect_layout",33554432,5,[[[2,-658,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,200],[0,0.5,1]],[7,-659],[34,41,160,-100,540,768,-660],-661],4,4,4,1],[1,0,-160,0]],[29,".demand_layout",33554432,5,[[[2,-662,[0,"71kmounFRG/K27WWBbH2RB"],[5,540,180],[0,0.5,1]],[7,-663],[34,41,400,-100,540,768,-664],-665],4,4,4,1],[1,0,-400,0]],[6,".0",33554432,50,[-669,-670],[[1,-666,[0,"f7NISe7HdAD68SLfhnddy8"],[5,180,32]],[264,3,false,-668,[0,"3cKHsskBlFGJNiDhihPR3l"],-667,140]],[1,0,-16,0]],[281,3,[[10,"53d46riXTpJo6q8nepchkB3","toggleDemand",8]]],[28,"label",2,70,[[207,"读取数据中",40,false,0,-671,[4,4283291713],177,178],[282,true,-672,[179],180],[7,-673],[11,-674,[5,200,50.4]]]],[66,"cursor",false,33554432,72,[[[1,-675,[0,"f7NISe7HdAD68SLfhnddy8"],[5,180,32]],-676,[19,45,140,32,-677]],4,1,4]],[5,["12BtlrGU9Kp6cfll4JHAJN"]],[4,".name",33554432,31,[[2,-678,[0,"c68UOAlNhN171Umca6yVvF"],[5,120,25.2],[0,0,1]],[116,"太阳系",0,20,20,20,1,false,true,1,-679,[0,"2frm37uaJHQr0AEEaYyM82"],24],[93,1.5,-680,[4,4278197040]]],[1,-66,-7.658,0]],[4,"Sprite",33554432,32,[[1,-681,[0,"f7NISe7HdAD68SLfhnddy8"],[5,28,28]],[112,0,-682,[0,"e71ctEmpxFC4KlSYRZNz/a"],25,26],[36,10,158,-683]],[1,46,0,0]],[4,".icon",33554432,32,[[1,-684,[0,"f7NISe7HdAD68SLfhnddy8"],[5,24,24]],[25,0,-685,[0,"e71ctEmpxFC4KlSYRZNz/a"],27],[36,10,5,-686]],[1,-109,0,0]],[4,".now",33554432,32,[[1,-687,[0,"c68UOAlNhN171Umca6yVvF"],[5,60,30.24]],[71,"10000",0,20,20,24,1,-688,[0,"2frm37uaJHQr0AEEaYyM82"]],[23,10,30,179.74,42.26,-689]],[1,-66,0,0]],[28,".addition",33554432,32,[[1,-690,[0,"c68UOAlNhN171Umca6yVvF"],[5,60,30.24]],[48,"+666.0",2,18,18,24,1,-691,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4283716095]],[23,10,96,179.74,42.26,-692]]],[4,".max",33554432,32,[[1,-693,[0,"c68UOAlNhN171Umca6yVvF"],[5,60,30.24]],[71,"10000",2,20,20,24,1,-694,[0,"2frm37uaJHQr0AEEaYyM82"]],[23,34,30,5,42.26,-695]],[1,91,0,0]],[4,".name",33554432,16,[[2,-696,[0,"c68UOAlNhN171Umca6yVvF"],[5,120,25.2],[0,0,1]],[116,"太阳系",0,20,20,20,1,false,true,1,-697,[0,"2frm37uaJHQr0AEEaYyM82"],31],[93,1.5,-698,[4,4281335835]]],[1,-66,-7.658,0]],[4,"Sprite",33554432,33,[[1,-699,[0,"f7NISe7HdAD68SLfhnddy8"],[5,28,28]],[112,0,-700,[0,"e71ctEmpxFC4KlSYRZNz/a"],32,33],[36,10,158,-701]],[1,46,0,0]],[4,".icon",33554432,33,[[1,-702,[0,"f7NISe7HdAD68SLfhnddy8"],[5,24,24]],[25,0,-703,[0,"e71ctEmpxFC4KlSYRZNz/a"],34],[36,10,5,-704]],[1,-109,0,0]],[4,".now",33554432,33,[[1,-705,[0,"c68UOAlNhN171Umca6yVvF"],[5,60,30.24]],[71,"10000",0,20,20,24,1,-706,[0,"2frm37uaJHQr0AEEaYyM82"]],[23,10,30,179.74,42.26,-707]],[1,-66,0,0]],[28,".addition",33554432,33,[[1,-708,[0,"c68UOAlNhN171Umca6yVvF"],[5,60,30.24]],[48,"+666.0",2,18,18,24,1,-709,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4288256511]],[23,10,96,179.74,42.26,-710]]],[4,".max",33554432,33,[[1,-711,[0,"c68UOAlNhN171Umca6yVvF"],[5,60,30.24]],[71,"10000",2,20,20,24,1,-712,[0,"2frm37uaJHQr0AEEaYyM82"]],[23,34,30,5,42.26,-713]],[1,91,0,0]],[4,".pos",33554432,24,[[2,-714,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,40.32],[0,0,1]],[48,"X:000  Y:000  Z:000",2,24,24,32,1,-715,[0,"2frm37uaJHQr0AEEaYyM82"],[4,3757737590]],[190,32,10,10,-716]],[1,-60,-49.468,0]],[4,".starnum",33554432,24,[[2,-717,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,40.32],[0,0,1]],[48,"星球数量：9",0,24,24,32,1,-718,[0,"2frm37uaJHQr0AEEaYyM82"],[4,3758096383]],[23,8,10,10,320,-719]],[1,-260,-99.262,0]],[57,".prosperity",false,33554432,24,[[2,-720,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,40.32],[0,0,1]],[48,"繁荣度：660",0,24,24,32,1,-721,[0,"2frm37uaJHQr0AEEaYyM82"],[4,3758096383]],[23,8,10,10,320,-722]],[1,-260,-137.812,0]],[4,".settled",33554432,24,[[2,-723,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,40.32],[0,0,1]],[48,"定居时间：2021年9月",0,24,24,32,1,-724,[0,"2frm37uaJHQr0AEEaYyM82"],[4,3758096383]],[23,8,10,10,320,-725]],[1,-260,-137.812,0]],[4,".action",33554432,9,[[1,-726,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,300,97.8]],[125,30,"<color=#80C2FF>RichText</color> 星系\n转运至\n<color=#80C2FF>RichText</color> 星系",1,30,300,-727,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[126,0,-728]],[1,0,-208.814,0]],[4,".cost",33554432,9,[[1,-729,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,300,31.5]],[125,25,"需额外消耗能源 <color=#80FFC2>666</color>",1,20,300,-730,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[126,0,-731]],[1,0,-367.106,0]],[4,".from_title",33554432,9,[[2,-732,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,400,37.8],[0,0,1]],[75,30,"<color=#80C2FF>RichText</color> 星系资源存量：",24,400,-733,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[36,8,10,-734]],[1,-260,-59.892,0]],[4,".to_title",33554432,9,[[2,-735,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,400,37.8],[0,0,1]],[75,30,"<color=#80C2FF>RichText</color> 星系仓库空余：",24,400,-736,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[36,8,10,-737]],[1,-260,-381.144,0]],[5,["65oRw/zGhLMrepg83LtCoA"]],[4,"pos_title",33554432,17,[[2,-738,[0,"c68UOAlNhN171Umca6yVvF"],[5,520,40.32],[0,0,1]],[208,"目标星系坐标",24,24,24,1,false,-739,[0,"2frm37uaJHQr0AEEaYyM82"],[4,3751411711],59],[23,40,10,10,320,-740]],[1,-260,-198.19100000000003,0]],[4,".from_title",33554432,17,[[2,-741,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,400,37.8],[0,0,1]],[75,30,"当前 <color=#80C2FF>RichText</color> 星系资源存量：",24,400,-742,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[36,8,10,-743]],[1,-260,-59.892,0]],[4,"res_title",33554432,17,[[2,-744,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,400,37.8],[0,0,1]],[75,30,"探索新星系所需资源：",24,400,-745,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[36,8,10,-746]],[1,-260,-350,0]],[5,["88uwYuFfFE2KCQtjT7EVQg"]],[32,".0",33554432,89,[-748,45],[[1,-747,[0,"dd2jcUd6NPorAPzM+Ys4zB"],[5,520,32]]]],[4,".axis",33554432,133,[[1,-749,[0,"c68UOAlNhN171Umca6yVvF"],[5,60,32]],[61,"X",0,21,20,20,2,false,1,-750,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],62],[191,12,60,4,360,-751,[0,"fe7OmRbg1ERKz3p59qXRbR"]]],[1,-230,0,0]],[4,".name",33554432,7,[[2,-752,[0,"c68UOAlNhN171Umca6yVvF"],[5,600,45],[0,1,1]],[209,"太阳系",2,0,40,45,1,false,1,-753,[0,"2frm37uaJHQr0AEEaYyM82"],75],[46,33,10,6,-754]],[1,630,378,0]],[57,".prosperity",false,33554432,7,[[2,-755,[0,"c68UOAlNhN171Umca6yVvF"],[5,180,25.2],[0,1,1]],[16,"繁荣度：600",2,20,20,20,1,false,1,-756,[0,"2frm37uaJHQr0AEEaYyM82"],76],[46,33,10,54,-757]],[1,630,330,0]],[4,".state",33554432,7,[[2,-758,[0,"c68UOAlNhN171Umca6yVvF"],[5,180,25.2],[0,1,1]],[16,"运行正常",2,20,20,20,1,false,1,-759,[0,"2frm37uaJHQr0AEEaYyM82"],77],[46,33,10,79,-760]],[1,630,305,0]],[4,".time",33554432,7,[[2,-761,[0,"c68UOAlNhN171Umca6yVvF"],[5,180,25.2],[0,1,1]],[16,"2021年9月",2,20,20,20,1,false,1,-762,[0,"2frm37uaJHQr0AEEaYyM82"],78],[46,33,10,104,-763]],[1,630,280,0]],[18,"key",512,33554432,90,[[1,-764,[0,"c68UOAlNhN171Umca6yVvF"],[5,380,31.5]],[61,"类型",0,20,20,25,3,false,1,-765,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],79],[47,32,10,0.25,380,-766]]],[41,"value",512,33554432,90,[[1,-767,[0,"c68UOAlNhN171Umca6yVvF"],[5,80,31.5]],[16,"bug",2,20,20,25,3,false,1,-768,[0,"2frm37uaJHQr0AEEaYyM82"],80],[47,32,10,3.149999999999997,380,-769]],[1,150,0,0]],[18,"key",512,33554432,60,[[1,-770,[0,"c68UOAlNhN171Umca6yVvF"],[5,380,31.5]],[61,"星球半径",0,20,20,25,3,false,1,-771,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],81],[47,32,10,3.149999999999997,380,-772]]],[41,"value",512,33554432,60,[[1,-773,[0,"c68UOAlNhN171Umca6yVvF"],[5,200,31.5]],[16,"5",2,20,20,25,3,false,1,-774,[0,"2frm37uaJHQr0AEEaYyM82"],82],[35,32,10,40,3.149999999999997,380,-775]],[1,50,0,0]],[41,"danwei",512,33554432,60,[[1,-776,[0,"c68UOAlNhN171Umca6yVvF"],[5,80,31.5]],[16,"km",2,20,20,25,3,false,1,-777,[0,"2frm37uaJHQr0AEEaYyM82"],83],[47,32,10,3.149999999999997,380,-778]],[1,150,0,0]],[18,"key",512,33554432,61,[[1,-779,[0,"c68UOAlNhN171Umca6yVvF"],[5,380,31.5]],[61,"轨道半径",0,20,20,25,3,false,1,-780,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],84],[47,32,10,3.149999999999997,380,-781]]],[41,"value",512,33554432,61,[[1,-782,[0,"c68UOAlNhN171Umca6yVvF"],[5,200,31.5]],[16,"1",2,20,20,25,3,false,1,-783,[0,"2frm37uaJHQr0AEEaYyM82"],85],[35,32,10,40,3.149999999999997,380,-784]],[1,50,0,0]],[41,"danwei",512,33554432,61,[[1,-785,[0,"c68UOAlNhN171Umca6yVvF"],[5,80,31.5]],[16,"AU",2,20,20,25,3,false,1,-786,[0,"2frm37uaJHQr0AEEaYyM82"],86],[47,32,10,3.149999999999997,380,-787]],[1,150,0,0]],[4,"resource_title",33554432,6,[[1,-788,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,400,37.8]],[210,"资源概览",28,28,28,1,-789],[34,40,106,-206,540,768,-790]],[1,0,-174.9,0]],[4,".name",33554432,18,[[1,-791,[0,"c68UOAlNhN171Umca6yVvF"],[5,160,32]],[16,"戴森球系统 III",0,20,20,20,1,false,1,-792,[0,"2frm37uaJHQr0AEEaYyM82"],109],[45,9,10,4,-793]],[1,-100,20,0]],[4,".state",33554432,18,[[1,-794,[0,"c68UOAlNhN171Umca6yVvF"],[5,80,32]],[72,"正常",20,20,20,1,false,1,-795,[0,"2frm37uaJHQr0AEEaYyM82"],110],[45,1,10,4,-796]],[1,61.287,20,0]],[154,"new",false,33554432,18,[[1,-797,[0,"c68UOAlNhN171Umca6yVvF"],[5,200,50.4]],[211,"建立新设施",40,false,1,-798,[0,"2frm37uaJHQr0AEEaYyM82"],112],[251,1,-799,[[10,"472b4yu8a9PjKp5Zk4EdQK+","callFacility",1]]]]],[4,".name",33554432,10,[[2,-800,[0,"c68UOAlNhN171Umca6yVvF"],[5,200,40.32],[0,0,1]],[212,"科技研发",0,32,32,32,1,1,-801,[0,"2frm37uaJHQr0AEEaYyM82"]],[45,9,10,10,-802]],[1,-182,-10,0]],[4,".description",33554432,10,[[2,-803,[0,"c68UOAlNhN171Umca6yVvF"],[5,364,127.8],[0,0,1]],[16,"科学技术的进步是探索宇宙不可缺少的一环。做好科学技术资源储备可以为星际探索事业增动赋能。AI助手将继续为您服务。",0,20,20,30,3,false,1,-804,[0,"2frm37uaJHQr0AEEaYyM82"],125],[35,41,10,10,60,380,-805]],[1,-182,-60,0]],[5,["88uwYuFfFE2KCQtjT7EVQg"]],[4,".state",33554432,10,[[2,-806,[0,"c68UOAlNhN171Umca6yVvF"],[5,200,40.32],[0,0,1]],[213,"未研发",2,24,24,24,1,1,-807,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284940134]],[192,33,10,10,10,-808]],[1,-18,-10,0]],[4,".title",33554432,5,[[1,-809,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,540,55]],[117,"建筑升级",32,32,32,1,false,1,-810,137],[34,40,106,-206,540,768,-811]],[1,0,-32.5,0]],[29,".action_title",33554432,5,[[[2,-812,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,430.77,30.240000000000002],[0,0,0.5]],-813,[44,8,10,3.149999999999997,380,-814,[0,"12wDXNr/pNvrWv3M5t8qht"]]],4,1,4],[1,-260,-75.12,0]],[4,".description",33554432,5,[[1,-815,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,520,55]],[117,"基地是星系运行的中枢系统，提供基础资源存储容量。\n如果基地被破坏，星系所有设施都将停止运行。",20,20,23,1,false,1,-816,138],[30,40,10,10,106,-206,540,768,-817]],[1,0,-119.321,0]],[41,".demand_title",512,33554432,5,[[2,-818,[0,"779kAXGTtMZKXfYlOg0Tfd"],[5,300,30.24],[0,0,1]],[214,"升级所需条件：",0,24,24,24,1,false,false,1,-819,[0,"ddIY+NJvlDTIQAg7PLVrGo"],139],[193,10,10,3.149999999999997,-48,380,-820,[0,"12wDXNr/pNvrWv3M5t8qht"]]],[1,-260,-366.88,0]],[29,"Label",33554432,3,[[[1,-821,[0,"c68UOAlNhN171Umca6yVvF"],[5,160,25.2]],-822,[58,40,10,40,120,-823,[0,"abNLnKOldJcYkOhF1jAcwL"]]],4,1,4],[1,-15,0,0]],[66,"cursor",false,33554432,103,[[[1,-824,[0,"f7NISe7HdAD68SLfhnddy8"],[5,180,32]],-825,[194,45,140,32,-826,[0,"87Oa9mQ3pLzpQL6wzNDpTn"]]],4,1,4]],[4,".title",33554432,19,[[1,-827,[0,"71F9vsVsZH7ZFd+PpN0azA"],[5,540,55]],[215,"矿难",32,32,32,1,1,-828],[34,40,106,-206,540,768,-829]],[1,0,-32.5,0]],[4,".description",33554432,19,[[2,-830,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,520,126.24],[0,0,1]],[227,24,"    比特币等数字货币的大幅度价格波动，使得显卡价格飞速上涨，已经对日常生活有了显著影响。\n    这次比特币价格的突然猛跌，使得 <color=#0cffda>比特星</color> 上的设施 <color=#acdaff>甲烷喷射器 II</color> 遭到严重坡坏，已经不能正常运作。目前警方已经介入相关调查。",20,520,-831,[0,"b5LFduq8VJWo/DE4BRFmBn"],159],[33,40,10,10,3.149999999999997,459.18000000000006,-832,[0,"12wDXNr/pNvrWv3M5t8qht"]]],[1,-260,-61.694,0]],[54,[24,"a4Lm6oRZ9O5piArwFkZGxG",-839,[38,"8aTDvSOsJF8IgRQomPLR6/",[[15,".0",["_name"],69],[9,["_lpos"],69,[1,0,0,0]],[9,["_lrot"],69,[3,0,0,0,1]],[258,["_materials","0"],[5,["492SVdw3ZPdre+amT+eLU6"]],174],[15,false,["_active"],69],[14,["_prefab","root"],69,-833],[9,["_lscale"],69,[1,1,1,1]],[15,1.3,["_range"],-834],[15,1,["_size"],-835],[15,true,["_active"],-836],[14,["_prefab","root"],-838,-837]]],173]],[164,"Main Camera","6crHsU/ctP+YUSM6p+TXpT",38,[[-840,[283,false,0.95,0.999,false,-841],[284,-842]],1,4,4],[1,0,0,-10],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[18,"Label",512,33554432,28,[[1,-843,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[118,"开始",20,20,1,false,-844,[0,"ee3IZdy2dLIaAWpjI7P0FL"],[4,4278190080]]]],[18,"Label",512,33554432,29,[[1,-845,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[118,"退出",20,20,1,false,-846,[0,"ee3IZdy2dLIaAWpjI7P0FL"],[4,4278190080]]]],[28,"value",33554432,72,[[1,-847,[0,"c68UOAlNhN171Umca6yVvF"],[5,160,25.2]],[73,"名字最长八个汉字",20,20,20,-848,[0,"2frm37uaJHQr0AEEaYyM82"]]]],[18,"Label",512,33554432,42,[[1,-849,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"科技树",20,20,1,false,-850,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[4,"title-001",33554432,22,[[2,-851,[0,"c68UOAlNhN171Umca6yVvF"],[5,128,40.32],[0,0.5,1]],[216,"当前星系",32,32,32,1,-852,[0,"2frm37uaJHQr0AEEaYyM82"]]],[1,0,-10,0]],[4,"title",33554432,22,[[2,-853,[0,"c68UOAlNhN171Umca6yVvF"],[5,128,40.32],[0,0.5,1]],[73,"其它星系",32,32,32,-854,[0,"2frm37uaJHQr0AEEaYyM82"]]],[1,0,-186,0]],[4,".state",33554432,31,[[2,-855,[0,"c68UOAlNhN171Umca6yVvF"],[5,80,25.2],[0,0.5,1]],[72,"运行正常",20,20,20,1,false,2,-856,[0,"2frm37uaJHQr0AEEaYyM82"],28]],[1,144.22,-8.254,0]],[29,"bar",33554432,75,[[[2,-857,[0,"95oWyE8aJJxJ5UvVmOXyZU"],[5,10,156.25],[0,0,0]],-858],4,1],[1,-11,-31.25,0]],[66,"cursor",false,33554432,16,[[[2,-859,[0,"f7NISe7HdAD68SLfhnddy8"],[5,390,128],[0,0.5,1]],-860],4,1]],[4,".state",33554432,16,[[2,-861,[0,"c68UOAlNhN171Umca6yVvF"],[5,80,25.2],[0,0.5,1]],[72,"运行正常",20,20,20,1,false,2,-862,[0,"2frm37uaJHQr0AEEaYyM82"],35]],[1,144.22,-8.254,0]],[140,true,54,[0,"352Lg0yJ1CEY+vaR56K/O8"]],[99,"Text_Label",512,33554432,44,[[[2,-863,[0,"779kAXGTtMZKXfYlOg0Tfd"],[5,298,50],[0,0,1]],-864],4,1],[1,-148,25,0]],[100,"PLACEHOLDER_LABEL",512,false,33554432,44,[[[2,-865,[0,"d07wQj4whCUqYGJH1lEpVp"],[5,298,50],[0,0,1]],-866],4,1],[1,-148,25,0]],[18,"Label",512,33554432,55,[[1,-867,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"前往星系",20,20,1,false,-868,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[5,["1bCHrwPGZOPrbmPh93kwpe"]],[4,"Label",33554432,9,[[1,-869,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,67.8]],[73,"跨星系运输资源需要额外消耗能源\n且不能溢出目标星系仓库",20,20,30,-870,[0,"2frm37uaJHQr0AEEaYyM82"]]],[1,0,-526.853,0]],[18,"Label",512,33554432,56,[[1,-871,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"转运",20,20,1,false,-872,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[165,"cursor",33554432,58,[[[1,-873,[0,"f7NISe7HdAD68SLfhnddy8"],[5,100,40]],-874],4,1]],[28,"value",33554432,58,[[1,-875,[0,"c68UOAlNhN171Umca6yVvF"],[5,96,50.4]],[217,"数据概览",24,24,-876,[0,"2frm37uaJHQr0AEEaYyM82"]]]],[29,"TEXT_LABEL",33554432,45,[[[2,-877,[0,"779kAXGTtMZKXfYlOg0Tfd"],[5,58,32],[0,0,1]],-878],4,1],[1,-28,16,0]],[166,"PLACEHOLDER_LABEL",false,33554432,45,[[[2,-879,[0,"d07wQj4whCUqYGJH1lEpVp"],[5,58,32],[0,0,1]],-880],4,1],[1,-28,16,0]],[18,"Label",512,33554432,15,[[1,-881,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"探索",20,20,1,false,-882,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[18,"Label",512,33554432,46,[[1,-883,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"星系",20,20,1,false,-884,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[99,"value",512,33554432,47,[[[2,-885,[0,"779kAXGTtMZKXfYlOg0Tfd"],[5,298,50],[0,0,1]],-886],4,1],[1,-148,25,0]],[100,"PLACEHOLDER_LABEL",512,false,33554432,47,[[[2,-887,[0,"d07wQj4whCUqYGJH1lEpVp"],[5,298,50],[0,0,1]],-888],4,1],[1,-148,25,0]],[6,"icon",33554432,2,[-890],[[11,-889,[5,100,32]]],[1,-50,60.5,0]],[28,"Sprite",33554432,190,[[1,-891,[0,"f7NISe7HdAD68SLfhnddy8"],[5,32,32]],[25,0,-892,[0,"e71ctEmpxFC4KlSYRZNz/a"],87]]],[6,"icon-001",33554432,2,[-894],[[11,-893,[5,100,32]]],[1,50,60.5,0]],[28,"Sprite",33554432,192,[[1,-895,[0,"f7NISe7HdAD68SLfhnddy8"],[5,32,32]],[25,0,-896,[0,"e71ctEmpxFC4KlSYRZNz/a"],88]]],[6,"icon-002",33554432,2,[-898],[[11,-897,[5,100,32]]],[1,150,60.5,0]],[28,"Sprite",33554432,194,[[1,-899,[0,"f7NISe7HdAD68SLfhnddy8"],[5,32,32]],[25,0,-900,[0,"e71ctEmpxFC4KlSYRZNz/a"],89]]],[4,"dense",33554432,2,[[11,-901,[5,100,31.5]],[74,"丰度",20,20,25,1,false,false,1,-902,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],90]],[1,-150,28.75,0]],[4,".0",33554432,2,[[11,-903,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-904,[0,"2frm37uaJHQr0AEEaYyM82"],91]],[1,-50,28.75,0]],[4,".1",33554432,2,[[11,-905,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-906,[0,"2frm37uaJHQr0AEEaYyM82"],92]],[1,50,28.75,0]],[4,".2",33554432,2,[[11,-907,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-908,[0,"2frm37uaJHQr0AEEaYyM82"],93]],[1,150,28.75,0]],[4,"difficulty",33554432,2,[[11,-909,[5,100,31.5]],[74,"开采难度",20,20,25,1,false,false,1,-910,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],94]],[1,-150,-2.75,0]],[4,".3",33554432,2,[[11,-911,[5,100,31.5]],[22,"低",20,20,25,1,false,false,1,-912,[0,"2frm37uaJHQr0AEEaYyM82"],95]],[1,-50,-2.75,0]],[4,".4",33554432,2,[[11,-913,[5,100,31.5]],[22,"低",20,20,25,1,false,false,1,-914,[0,"2frm37uaJHQr0AEEaYyM82"],96]],[1,50,-2.75,0]],[4,".5",33554432,2,[[11,-915,[5,100,31.5]],[22,"低",20,20,25,1,false,false,1,-916,[0,"2frm37uaJHQr0AEEaYyM82"],97]],[1,150,-2.75,0]],[4,".production",33554432,2,[[11,-917,[5,100,31.5]],[74,"产能",20,20,25,1,false,false,1,-918,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],98]],[1,-150,-34.25,0]],[4,".6",33554432,2,[[11,-919,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-920,[0,"2frm37uaJHQr0AEEaYyM82"],99]],[1,-50,-34.25,0]],[4,".7",33554432,2,[[11,-921,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-922,[0,"2frm37uaJHQr0AEEaYyM82"],100]],[1,50,-34.25,0]],[4,".8",33554432,2,[[11,-923,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-924,[0,"2frm37uaJHQr0AEEaYyM82"],101]],[1,150,-34.25,0]],[4,".capacity",33554432,2,[[11,-925,[5,100,31.5]],[74,"容量",20,20,25,1,false,false,1,-926,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4294957740],102]],[1,-150,-65.75,0]],[4,".9",33554432,2,[[11,-927,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-928,[0,"2frm37uaJHQr0AEEaYyM82"],103]],[1,-50,-65.75,0]],[4,".10",33554432,2,[[11,-929,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-930,[0,"2frm37uaJHQr0AEEaYyM82"],104]],[1,50,-65.75,0]],[4,".11",33554432,2,[[11,-931,[5,100,31.5]],[22,"0",20,20,25,1,false,false,1,-932,[0,"2frm37uaJHQr0AEEaYyM82"],105]],[1,150,-65.75,0]],[4,"facility",33554432,6,[[2,-933,[0,"c68UOAlNhN171Umca6yVvF"],[5,380,40.32],[0,0.5,1]],[72,"星球设施",28,28,28,1,false,1,-934,[0,"2frm37uaJHQr0AEEaYyM82"],106]],[1,0,-356.8,0]],[29,"bar",33554432,64,[[[2,-935,[0,"95oWyE8aJJxJ5UvVmOXyZU"],[5,160,10],[0,0,0]],-936],4,1],[1,-200,-5,0]],[285,true,64,[0,"f4i77UV0dH4pcD0KQOXx7c"]],[66,".bg",false,33554432,98,[[[1,-937,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,160,40]],-938],4,1]],[32,"labels",33554432,49,[-940],[[103,-939,[0,0,0]]]],[4,"TechLabel",33554432,216,[[1,-941,[0,"c68UOAlNhN171Umca6yVvF"],[5,160,40]],[218,21,20,20,2,false,1,-942,[0,"2frm37uaJHQr0AEEaYyM82"],123]],[1,101.69999999999999,200,0]],[4,".requirement",33554432,10,[[2,-943,[0,"c68UOAlNhN171Umca6yVvF"],[5,380,40.32],[0,0.5,1]],[219,"请先于左侧选择研发项目",32,32,32,1,1,-944,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4288282623]]],[1,0,-340.71,0]],[18,"Label",512,33554432,66,[[1,-945,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"研发",20,20,1,false,-946,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[28,"value",33554432,103,[[1,-947,[0,"c68UOAlNhN171Umca6yVvF"],[5,160,25.2]],[73,"名字最长八个汉字",20,20,20,-948,[0,"2frm37uaJHQr0AEEaYyM82"]]]],[18,"value",512,33554432,26,[[1,-949,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[220,"建造/升级/维修",20,20,1,false,1,-950,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[18,"Label",512,33554432,51,[[1,-951,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"取消",20,20,1,false,-952,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[287,8,[-953,-954],104,[157,158]],[18,"value",512,33554432,67,[[1,-955,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"了解",20,20,1,false,-956,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[18,"value",512,33554432,68,[[1,-957,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[31,"看不见",20,20,1,false,-958,[0,"ee3IZdy2dLIaAWpjI7P0FL"]]]],[168,"Galaxy","7exgc9/tNB0byq2aHBbhfv",38,[163],[-959],[3,-0.49999999999999994,0,0,0.8660254037844387],[1,-60,0,0]],[169,"Camera",33554432,1,[-960],[1,0,0,1000]],[288,0,1073741824,397.63713080168776,2000,6,41943041,227,[4,4278190080]],[37,1,0,106,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[140,true,39,[0,"352Lg0yJ1CEY+vaR56K/O8"]],[37,1,0,172,[0,"02Vchn8fFF/77B+7pVCQuQ"]],[286,1,75,[0,"f4i77UV0dH4pcD0KQOXx7c"],231],[290,0.23,0.75,false,43,[0,"a8UaPDxYhIX5MrqvKGMJdR"],54,232],[37,1,0,173,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[292,false,4,[23,20,25],[175,-961],[[57,null,null,null],6,0,0,0]],[119,"最多六个汉字",0,32,32,1,false,false,176,[0,"ddIY+NJvlDTIQAg7PLVrGo"],[4,4289853951]],[120,"请输入名称..",0,28,28,50,1,false,false,177,[0,"8fhi7qRLFJbK0abIJuXmCW"],[4,4290493371]],[5,["b0ctIOeuhBLKQAXVKX5iB+"]],[5,["b0ctIOeuhBLKQAXVKX5iB+"]],[141,57,[0,"352Lg0yJ1CEY+vaR56K/O8"],[[94]]],[37,1,0,182,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[5,["b0ctIOeuhBLKQAXVKX5iB+"]],[5,["a3MlKCXHJKSok4lo4/42b6"]],[5,["f4ZTC++QNPt5fzcwVdVdmM"]],[5,["b5p/0oIDZGM5DqQ3cbh58r"]],[121,"999",2,20,20,1,false,1,184,[0,"ddIY+NJvlDTIQAg7PLVrGo"]],[122,"000",0,20,20,32,1,false,185,[0,"8fhi7qRLFJbK0abIJuXmCW"],[4,4290493371]],[119,"名字最多八个汉字",0,32,32,1,false,false,188,[0,"ddIY+NJvlDTIQAg7PLVrGo"],[4,4289853951]],[120,"请输入名称..",0,28,28,50,1,false,false,189,[0,"8fhi7qRLFJbK0abIJuXmCW"],[4,4290493371]],[4,"Node",33554432,2,[[11,-962,[5,100,32]]],[1,-150,60.5,0]],[37,1,0,92,[0,"77BcV1zfNHo4LI4KRqZupe"]],[37,1,0,93,[0,"77BcV1zfNHo4LI4KRqZupe"]],[5,["b0ctIOeuhBLKQAXVKX5iB+"]],[113,1,0,213,[0,"02Vchn8fFF/77B+7pVCQuQ"],[4,16777215]],[291,0.23,0.75,false,48,[0,"a8UaPDxYhIX5MrqvKGMJdR"],49,214,214],[37,1,0,215,[0,"77BcV1zfNHo4LI4KRqZupe"]],[5,["a3MlKCXHJKSok4lo4/42b6"]],[5,["f4ZTC++QNPt5fzcwVdVdmM"]],[5,["b5p/0oIDZGM5DqQ3cbh58r"]],[252,false,2,66,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[10,"cc32ae4iWRCbpNIabux8iPV","callResearch",13]],[4,4292269782],15],[228,24,"升级建筑 <color=#acdaff>甲烷喷射器 II</color> 至等级 <color=#0cdaff>III</color> 效果：",24,false,156,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[128,2,2,101],[128,2,2,102],[221,"当前选项内容",21,20,20,2,159,[0,"2frm37uaJHQr0AEEaYyM82"]],[37,1,0,160,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[141,50,[0,"352Lg0yJ1CEY+vaR56K/O8"],[[10,"940d4XZy2ZHpZq0HhvR6iwH","setChoice",3]]],[201,1,0,3],[293,14,19],[294,226],[5,["5b6a86+adN0IKor4mk41YN"]],[5,["7eUgTcD7ZCtrfB9UhkGdeE"]],[289,60,14,1822425087,164],[155,"Directional Light","b3ZrKKYCRGcrY0s5o2qlx9",38,[[295,true,16000,-963,[0,"1fmNgOipdOha90C8NNkXEN"],[4,4284284672],[142]]],[1,0,0,-6.821],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[170,"Particle","28ASOnRyZGsYilC2ccal7W",38,[-964],[3,0.7071067811865475,0,0,0.7071067811865476],[1,3,3,3],[1,90,0,0]],[297,800,274,[0,"0b7a7v3FVOCpzmec7amMlB"],[[175,null],6,0],[95],[40,1],[12],[12],[40,0.5],[12],[12],[12],[12],[40,5],[12],[40,160],[12],[300,true,[298,1,[301,[[302,[4,4294965615]],[303,1,[4,4294021972]]],[[143,255,0.7879464285714286],[143,0,1]]]]],[304,true,3,2,50,[40,1]],[305,true,[299,2,[144,2,8,[[145],[82,0.82,0.55,-0.7692307692307692,-0.7692307692307692],[82,1,0.01,-1.6140350877192982,-1.6140350877192982]]],[144,2,8,[[145],[82,0.82,1,-0.7692307692307692,-0.7692307692307692],[82,1,0.01,-1.6140350877192982,-1.6140350877192982]]]],[12],[12],[12]],[306,[12],[12],[12],[40,1]],[307,[12],[12],[12]],[308,[12],[12],[12],[12]],[309,[12],[12],[12]],[310,[12],[12]],[311,[40,1],[12],[95],[95],-965],[312,176]]],0,[0,28,228,0,0,1,0,0,1,0,-1,235,0,29,268,0,30,223,0,-1,8,0,-2,14,0,31,34,0,-1,230,0,-2,175,0,32,269,0,33,36,0,-1,11,0,-2,13,0,-3,4,0,0,1,0,0,1,0,0,1,0,-1,227,0,-2,27,0,-3,11,0,-4,13,0,-5,4,0,-6,36,0,-7,8,0,-8,14,0,0,2,0,0,2,0,0,2,0,-1,250,0,-2,190,0,-3,192,0,-4,194,0,-5,196,0,-6,197,0,-7,198,0,-8,199,0,-9,200,0,-10,201,0,-11,202,0,-12,203,0,-13,204,0,-14,205,0,-15,206,0,-16,207,0,-17,208,0,-18,209,0,-19,210,0,-20,211,0,0,3,0,0,3,0,-3,104,0,0,3,0,-5,267,0,12,3,0,24,3,0,0,3,0,-1,159,0,-2,50,0,0,4,0,0,4,0,0,4,0,-4,235,0,-1,22,0,-2,21,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,-1,155,0,-2,156,0,-3,157,0,-4,101,0,-5,158,0,-6,102,0,-8,26,0,-9,51,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,-1,47,0,-2,90,0,-3,60,0,-4,61,0,-5,147,0,-7,212,0,-8,91,0,0,7,0,0,7,0,0,7,0,0,7,0,-1,40,0,-2,41,0,-3,53,0,-4,135,0,-5,136,0,-6,137,0,-7,138,0,0,8,0,0,8,0,0,8,0,0,8,0,24,8,0,0,8,0,-6,223,0,0,9,0,0,9,0,0,9,0,-1,124,0,-2,125,0,-3,126,0,-4,127,0,-5,78,0,-6,80,0,-7,82,0,-8,180,0,0,10,0,0,10,0,0,10,0,0,10,0,-1,151,0,-2,152,0,-3,99,0,-4,218,0,-5,154,0,-6,66,0,0,11,0,0,11,0,0,11,0,-2,34,0,0,11,0,0,11,0,-1,39,0,-2,73,0,-4,34,0,3,81,0,3,81,0,3,81,0,4,12,0,3,81,0,3,179,0,3,179,0,3,179,0,4,12,0,4,12,0,4,12,0,4,12,0,3,81,0,8,12,0,0,13,0,0,13,0,0,13,0,34,260,0,35,49,0,0,13,0,-1,48,0,-3,35,0,0,14,0,0,14,0,0,14,0,0,14,0,0,14,0,-6,268,0,-1,19,0,0,15,0,0,15,0,12,15,0,0,15,0,-1,186,0,0,16,0,0,16,0,18,234,0,12,16,0,0,16,0,0,16,0,-1,173,0,-2,114,0,-3,77,0,-4,174,0,0,17,0,0,17,0,0,17,0,-1,129,0,-2,130,0,-3,131,0,-4,85,0,-5,88,0,-6,89,0,0,18,0,0,18,0,0,18,0,36,63,0,-1,252,0,-2,251,0,0,18,0,-1,62,0,-2,148,0,-3,149,0,-4,63,0,-5,150,0,0,19,0,0,19,0,0,19,0,0,19,0,-1,161,0,-2,162,0,-3,67,0,-4,68,0,0,20,0,0,20,0,0,20,0,0,20,0,0,20,0,0,21,0,0,21,0,0,21,0,0,21,0,-1,57,0,-2,23,0,-3,25,0,0,22,0,0,22,0,0,22,0,0,22,0,-1,169,0,-2,170,0,-3,31,0,-4,43,0,0,23,0,0,23,0,0,23,0,0,23,0,0,23,0,-1,24,0,-2,55,0,0,24,0,0,24,0,0,24,0,-1,120,0,-2,121,0,-3,122,0,-4,123,0,-5,44,0,0,25,0,0,25,0,0,25,0,0,25,0,0,25,0,-2,56,0,0,26,0,0,26,0,12,26,0,0,26,0,0,26,0,-1,221,0,0,27,0,0,27,0,0,27,0,-1,52,0,-2,71,0,-3,28,0,-4,29,0,0,28,0,0,28,0,0,28,0,12,28,0,0,28,0,0,28,0,-1,165,0,0,29,0,0,29,0,0,29,0,12,29,0,0,29,0,0,29,0,-1,166,0,3,107,0,3,107,0,3,107,0,4,30,0,3,107,0,4,30,0,4,30,0,4,30,0,4,30,0,4,30,0,8,30,0,0,31,0,0,31,0,0,31,0,0,31,0,-1,108,0,-2,74,0,-3,171,0,0,32,0,0,32,0,-1,109,0,-2,110,0,-3,111,0,-4,112,0,-5,113,0,0,33,0,0,33,0,-1,115,0,-2,116,0,-3,117,0,-4,118,0,-5,119,0,0,34,0,0,34,0,0,34,0,0,34,0,3,100,0,3,100,0,3,100,0,4,35,0,3,100,0,4,35,0,4,35,0,4,35,0,4,35,0,4,35,0,3,100,0,8,35,0,0,36,0,0,36,0,0,36,0,12,36,0,0,36,0,0,36,0,0,37,0,0,37,0,0,37,0,0,37,0,0,37,0,0,37,0,-1,70,0,20,223,0,20,104,0,20,104,0,20,104,0,-2,273,0,-3,164,0,-4,274,0,-5,226,0,0,39,0,0,39,0,-3,230,0,0,39,0,0,39,0,-1,72,0,0,40,0,0,40,0,0,40,0,12,40,0,0,40,0,0,40,0,0,41,0,0,41,0,0,41,0,12,41,0,0,41,0,0,41,0,0,42,0,0,42,0,0,42,0,0,42,0,0,42,0,-1,168,0,0,43,0,0,43,0,-3,233,0,0,43,0,-1,75,0,-2,76,0,0,44,0,21,237,0,22,236,0,0,44,0,0,44,0,0,44,0,-1,176,0,-2,177,0,0,45,0,0,45,0,21,247,0,22,246,0,0,45,0,0,45,0,-1,184,0,-2,185,0,0,46,0,0,46,0,0,46,0,0,46,0,0,46,0,-1,187,0,0,47,0,21,249,0,22,248,0,0,47,0,0,47,0,0,47,0,-1,188,0,-2,189,0,0,48,0,-2,255,0,0,48,0,0,48,0,-1,64,0,-2,96,0,0,49,0,0,49,0,-1,97,0,-2,216,0,0,50,0,0,50,0,-3,266,0,0,50,0,0,50,0,-1,103,0,0,51,0,0,51,0,12,51,0,0,51,0,0,51,0,-1,222,0,0,52,0,0,52,0,0,52,0,0,52,0,0,52,0,0,53,0,0,53,0,0,53,0,0,54,0,0,54,0,-3,175,0,0,55,0,0,55,0,12,55,0,0,55,0,-1,178,0,0,56,0,0,56,0,0,56,0,0,56,0,-1,181,0,0,57,0,0,57,0,-3,240,0,0,57,0,-1,58,0,0,58,0,0,58,0,18,241,0,0,58,0,-1,182,0,-2,183,0,3,132,0,3,132,0,3,132,0,4,59,0,3,132,0,4,59,0,3,243,0,3,243,0,4,59,0,3,244,0,3,244,0,4,59,0,3,245,0,3,245,0,8,59,0,0,60,0,0,60,0,-1,141,0,-2,142,0,-3,143,0,0,61,0,0,61,0,-1,144,0,-2,145,0,-3,146,0,0,62,0,0,62,0,0,62,0,-1,92,0,-2,93,0,0,63,0,0,63,0,0,63,0,-1,94,0,0,64,0,0,64,0,0,64,0,-4,214,0,-1,213,0,3,153,0,3,153,0,3,153,0,4,65,0,3,153,0,4,65,0,3,257,0,3,257,0,4,65,0,3,258,0,3,258,0,4,65,0,3,259,0,3,259,0,8,65,0,0,66,0,0,66,0,-3,260,0,0,66,0,-1,219,0,0,67,0,0,67,0,0,67,0,0,67,0,-1,224,0,0,68,0,0,68,0,0,68,0,0,68,0,-1,225,0,0,70,0,0,70,0,0,70,0,0,70,0,-1,105,0,0,71,0,0,71,0,0,71,0,0,71,0,0,72,0,18,229,0,0,72,0,-1,106,0,-2,167,0,0,73,0,0,73,0,0,73,0,0,74,0,0,74,0,0,74,0,0,75,0,0,75,0,-3,232,0,-1,172,0,0,76,0,0,76,0,0,76,0,0,77,0,0,77,0,0,77,0,0,78,0,0,78,0,0,78,0,-1,79,0,3,128,0,3,128,0,3,128,0,4,79,0,3,128,0,4,79,0,3,238,0,3,238,0,4,79,0,8,79,0,0,80,0,0,80,0,0,80,0,0,82,0,0,82,0,0,82,0,-1,83,0,3,84,0,3,84,0,3,84,0,4,83,0,3,84,0,4,83,0,3,239,0,3,239,0,4,83,0,3,84,0,8,83,0,0,85,0,0,85,0,0,85,0,-1,86,0,3,87,0,3,87,0,3,87,0,4,86,0,3,87,0,4,86,0,3,242,0,3,242,0,4,86,0,3,87,0,8,86,0,0,88,0,0,88,0,0,88,0,0,89,0,0,89,0,0,89,0,-1,133,0,0,90,0,0,90,0,-1,139,0,-2,140,0,0,91,0,0,91,0,0,91,0,0,92,0,-2,251,0,12,92,0,0,92,0,0,93,0,-2,252,0,12,93,0,0,93,0,3,95,0,3,95,0,3,95,0,4,94,0,3,95,0,4,94,0,3,253,0,3,253,0,4,94,0,3,95,0,8,94,0,0,96,0,0,96,0,0,96,0,0,97,0,0,97,0,0,97,0,-1,98,0,0,98,0,0,98,0,18,256,0,0,98,0,-1,215,0,0,99,0,0,99,0,0,99,0,0,101,0,0,101,0,0,101,0,-4,262,0,0,102,0,0,102,0,0,102,0,-4,263,0,0,103,0,18,265,0,0,103,0,-1,160,0,-2,220,0,0,105,0,0,105,0,0,105,0,0,105,0,0,106,0,-2,229,0,0,106,0,0,108,0,0,108,0,0,108,0,0,109,0,0,109,0,0,109,0,0,110,0,0,110,0,0,110,0,0,111,0,0,111,0,0,111,0,0,112,0,0,112,0,0,112,0,0,113,0,0,113,0,0,113,0,0,114,0,0,114,0,0,114,0,0,115,0,0,115,0,0,115,0,0,116,0,0,116,0,0,116,0,0,117,0,0,117,0,0,117,0,0,118,0,0,118,0,0,118,0,0,119,0,0,119,0,0,119,0,0,120,0,0,120,0,0,120,0,0,121,0,0,121,0,0,121,0,0,122,0,0,122,0,0,122,0,0,123,0,0,123,0,0,123,0,0,124,0,0,124,0,0,124,0,0,125,0,0,125,0,0,125,0,0,126,0,0,126,0,0,126,0,0,127,0,0,127,0,0,127,0,0,129,0,0,129,0,0,129,0,0,130,0,0,130,0,0,130,0,0,131,0,0,131,0,0,131,0,0,133,0,-1,134,0,0,134,0,0,134,0,0,134,0,0,135,0,0,135,0,0,135,0,0,136,0,0,136,0,0,136,0,0,137,0,0,137,0,0,137,0,0,138,0,0,138,0,0,138,0,0,139,0,0,139,0,0,139,0,0,140,0,0,140,0,0,140,0,0,141,0,0,141,0,0,141,0,0,142,0,0,142,0,0,142,0,0,143,0,0,143,0,0,143,0,0,144,0,0,144,0,0,144,0,0,145,0,0,145,0,0,145,0,0,146,0,0,146,0,0,146,0,0,147,0,0,147,0,0,147,0,0,148,0,0,148,0,0,148,0,0,149,0,0,149,0,0,149,0,0,150,0,0,150,0,0,150,0,0,151,0,0,151,0,0,151,0,0,152,0,0,152,0,0,152,0,0,154,0,0,154,0,0,154,0,0,155,0,0,155,0,0,155,0,0,156,0,-2,261,0,0,156,0,0,157,0,0,157,0,0,157,0,0,158,0,0,158,0,0,158,0,0,159,0,-2,264,0,0,159,0,0,160,0,-2,265,0,0,160,0,0,161,0,0,161,0,0,161,0,0,162,0,0,162,0,0,162,0,4,163,0,3,270,0,3,270,0,3,271,0,4,163,0,3,271,0,8,163,0,-1,272,0,0,164,0,0,164,0,0,165,0,0,165,0,0,166,0,0,166,0,0,167,0,0,167,0,0,168,0,0,168,0,0,169,0,0,169,0,0,170,0,0,170,0,0,171,0,0,171,0,0,172,0,-2,231,0,0,173,0,-2,234,0,0,174,0,0,174,0,0,176,0,-2,236,0,0,177,0,-2,237,0,0,178,0,0,178,0,0,180,0,0,180,0,0,181,0,0,181,0,0,182,0,-2,241,0,0,183,0,0,183,0,0,184,0,-2,246,0,0,185,0,-2,247,0,0,186,0,0,186,0,0,187,0,0,187,0,0,188,0,-2,248,0,0,189,0,-2,249,0,0,190,0,-1,191,0,0,191,0,0,191,0,0,192,0,-1,193,0,0,193,0,0,193,0,0,194,0,-1,195,0,0,195,0,0,195,0,0,196,0,0,196,0,0,197,0,0,197,0,0,198,0,0,198,0,0,199,0,0,199,0,0,200,0,0,200,0,0,201,0,0,201,0,0,202,0,0,202,0,0,203,0,0,203,0,0,204,0,0,204,0,0,205,0,0,205,0,0,206,0,0,206,0,0,207,0,0,207,0,0,208,0,0,208,0,0,209,0,0,209,0,0,210,0,0,210,0,0,211,0,0,211,0,0,212,0,0,212,0,0,213,0,-2,254,0,0,215,0,-2,256,0,0,216,0,-1,217,0,0,217,0,0,217,0,0,218,0,0,218,0,0,219,0,0,219,0,0,220,0,0,220,0,0,221,0,0,221,0,0,222,0,0,222,0,-1,262,0,-2,263,0,0,224,0,0,224,0,0,225,0,0,225,0,-1,269,0,-1,228,0,-2,240,0,0,250,0,0,273,0,-1,275,0,37,275,0,38,38,1,5,38,2,5,6,3,5,5,5,5,8,6,5,34,7,5,11,9,5,25,10,5,13,12,5,80,15,5,20,16,5,54,17,5,20,18,5,91,20,5,21,30,5,73,32,5,74,33,5,77,37,5,38,42,5,53,45,5,133,46,5,53,49,5,96,54,5,76,59,5,88,65,5,99,104,39,266,104,40,267,104,41,264,163,5,226,214,42,254,214,25,255,223,43,261,232,25,233,269,44,272,965],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,229,231,234,236,237,241,248,249,251,252,254,256,260,260,260,260,261,261,265,267,269],[7,2,1,6,9,10,11,1,6,9,10,11,6,1,15,1,6,1,6,1,6,9,10,11,2,1,14,1,2,1,6,2,1,14,1,2,1,6,1,1,6,9,10,11,15,15,15,1,6,9,10,11,1,6,9,10,11,-1,1,2,15,15,2,1,26,1,6,9,10,11,1,6,9,10,11,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,6,6,2,2,15,2,1,-1,-2,-3,-4,45,1,1,1,6,2,1,2,15,1,1,15,-1,-2,1,6,9,10,11,2,2,2,6,1,6,9,10,11,1,6,9,10,11,1,6,9,10,11,1,-1,-2,23,1,6,9,10,11,1,6,9,10,11,1,46,47,15,4,-1,48,7,2,-1,49,7,1,-1,-2,-3,-4,-5,-6,-1,-1,-2,-3,1,1,1,2,2,1,2,2,1,1,1,1,6,9,10,11,2,23,1,1,50],[1,0,9,9,9,16,11,9,9,9,16,11,17,7,26,27,27,28,28,2,2,4,5,3,0,29,12,18,0,30,30,0,29,12,18,0,31,31,7,2,2,4,5,3,10,49,10,2,2,4,5,2,2,2,4,5,3,10,7,0,10,19,0,13,13,3,3,4,5,3,2,2,4,5,3,0,0,0,0,0,0,0,0,0,0,0,0,18,50,51,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,0,0,10,0,52,21,20,53,54,10,7,55,22,22,0,7,0,19,2,7,26,22,56,32,32,9,16,11,0,0,0,17,14,23,33,33,23,2,2,4,5,3,2,2,4,5,3,7,57,19,0,2,2,4,5,3,2,2,4,5,3,7,34,58,35,59,60,36,1,0,37,37,1,14,61,62,63,64,65,66,12,67,68,34,24,69,70,0,0,24,0,0,20,21,71,72,2,4,5,3,0,0,24,23,35]],[[[127,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_ALBEDO_MAP":true},{},{},{}],[[[{},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[19,17],[73,15]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"544e49d6-3f05-4fa8-9a9e-091f98fc2ce8@6c48a","packable":true}],[5],0,[0],[13],[74]],[[{"name":"default_sprite","rect":{"x":0,"y":2,"width":40,"height":36},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[0,0,0,0],"texture":"57520716-48c8-4a19-8acf-41c9f8777fb0@6c48a","packable":true}],[5],0,[0],[13],[75]],[[[27,"tinyItem"],[85,"tinyItem",[-4,-5],[[1,-2,[0,"dd2jcUd6NPorAPzM+Ys4zB"],[5,102.853,32]],[146,-3,[0,"06EmrRc2tA/olpnKbbNAUg"]]],[3,"65oRw/zGhLMrepg83LtCoA",-1,0]],[20,".icon",33554432,1,[[1,-6,[0,"f7NISe7HdAD68SLfhnddy8"],[5,24,24]],[25,0,-7,[0,"e71ctEmpxFC4KlSYRZNz/a"],0],[59,8,-8,[0,"27U6NhksNGA603JdrGl3d6"]]],[3,"b0ctIOeuhBLKQAXVKX5iB+",1,0],[1,-39.4265,0,0]],[20,".value",33554432,1,[[1,-9,[0,"c68UOAlNhN171Umca6yVvF"],[5,74.853,32]],[16,"123",2,21,20,20,2,false,1,-10,[0,"2frm37uaJHQr0AEEaYyM82"],1],[44,44,28,4,360,-11,[0,"fe7OmRbg1ERKz3p59qXRbR"]]],[3,"5f7f/3UudCNb7Y46M+/V3f",1,0],[1,14,0,0]]],0,[0,8,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,0,2,0,0,2,0,0,2,0,0,3,0,0,3,0,0,3,0,16,1,11],[0,0],[1,2],[25,0]],[[[27,"Planet"],[85,"Planet",[-7,-8],[[313,-6,[0,"7815nYvaRGPoqTESTbCIEr"],-5,-4,-3,-2]],[3,"a4Lm6oRZ9O5piArwFkZGxG",-1,0]],[156,"Sphere",1,[-10,-11],[[314,"Sphere<ModelComponent>",0,-9,[0,"492SVdw3ZPdre+amT+eLU6"],[2],[316,true],3]],[3,"7eUgTcD7ZCtrfB9UhkGdeE",1,0],[1,5,0,0],[1,2,2,2]],[157,"ring",2,[[315,"Torus<ModelComponent>",-12,[0,"2drVX38YdDtbq+q8MG+iKl"],[0],[317],1]],[3,"23H5gRllNGh5qLgF+DBKYL",1,0],[1,0.7,0.7,0.7]],[171,"Spot Light",1,[-13],[3,"446lOnRpxIM5L6T4+9O0OK",1,0],[1,2.999999999999999,0,0],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,1.9999999999999998,2,1.9999999999999998],[1,0,-89.99999999999999,0]],[318,true,5955,0.4,20,1,2,4,[0,"42FuKkPeBOSLyZuICQqfaf"],[142]],[172,"Sphere Light",false,2,[-14],[3,"dfm9ghGWRLhpu24OaeUVxC",1,0]],[319,true,6500,1,10132.118364233778,1.3,6,[0,"5b6a86+adN0IKor4mk41YN"],[296,true]]],0,[0,8,1,0,51,3,0,52,5,0,53,7,0,54,2,0,0,1,0,-1,4,0,-2,2,0,0,2,0,-1,6,0,-2,3,0,0,3,0,-1,5,0,-1,7,0,16,1,14],[0,0,0,0],[-1,27,-1,27],[76,77,78,79]],[[[225,"builtin-sprite",[{}],[{"hash":1559944983,"name":"builtin-sprite|sprite-vs:vert|sprite-fs:frag","glsl4":{"vert":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\n#if SAMPLE_FROM_RT\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n  layout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nlayout(location = 0) in vec4 color;\n#if USE_TEXTURE\n  layout(location = 1) in vec2 uv0;\n  layout(set = 2, binding = 10) uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  ALPHA_TEST(o);\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\n#if SAMPLE_FROM_RT\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n  layout(std140) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  ALPHA_TEST(o);\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n  return vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\n  return texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\n      uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  ALPHA_TEST(o);\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":["USE_TEXTURE"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":46,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":1}},"defines":[{"name":"USE_LOCAL","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean","defines":[]},{"name":"CC_USE_EMBEDDED_ALPHA","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"IS_GRAY","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]}],"samplerTextures":[],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":1,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":2,"defines":[]}],"varyings":[{"name":"color","type":16,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"uv0","type":14,"count":1,"stageFlags":1,"location":1,"defines":[]}]}],[{"passes":[{"program":"builtin-sprite|sprite-vs:vert|sprite-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"alphaThreshold":{"type":13,"value":[0.5]}}}]}]]],0,0,[],[],[]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"texture":"7d8f9b89-4fd1-4c9f-a3ab-38ec7cded7ca@6c48a","packable":true}],[5],0,[0],[13],[80]],[[[123,".bin",34032,3189241782,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":24816,"length":9216,"count":2304,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":24816,"count":517,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.252577543258667,0,-1.252577304840088],"maxPosition",8,[1,1.252577543258667,0,1.2525776624679565]]]],0,0,[],[],[]],[[[27,"TinyEdit"],[85,"TinyEdit",[-4,-5],[[1,-2,[0,"dd2jcUd6NPorAPzM+Ys4zB"],[5,520,32]],[146,-3,[0,"06EmrRc2tA/olpnKbbNAUg"]]],[3,"dfsCeqolZPwK0P5GVcIoMY",-1,0]],[42,".value",33554432,1,[-12,-13],[[1,-6,[0,"1fhJOVuOVAGYSYZoiE25Uz"],[5,80,32]],[13,1,0,-7,[0,"43qH95z3VGeYelCElKd6FW"],0],[277,"12345",2,5,-10,[0,"1bCHrwPGZOPrbmPh93kwpe"],[[94]],-9,-8,1],[44,36,28,4,360,-11,[0,"fe7OmRbg1ERKz3p59qXRbR"]]],[3,"f4AMWrbKZGFLDHBbYNgCis",1,0],[1,220,0,0]],[20,".icon",33554432,1,[[1,-14,[0,"3cUPswXdZJ2pkVseKmZVoS"],[5,24,24]],[25,0,-15,[0,"b8sdsTuolMdJDnhvqe5iuW"],2],[59,8,-16,[0,"9b+p9ea9NBnZXfcTnzbBjp"]]],[3,"06j2lE/NhNlbc9+gtWSnME",1,0],[1,-248,0,0]],[65,"TEXT_LABEL",33554432,2,[[[2,-17,[0,"779kAXGTtMZKXfYlOg0Tfd"],[5,78,32],[0,0,1]],-18],4,1],[3,"02KXwSs0NL1YlzUhyrWl3E",1,0],[1,-38,16,0]],[167,"PLACEHOLDER_LABEL",false,33554432,2,[[[2,-19,[0,"d07wQj4whCUqYGJH1lEpVp"],[5,78,32],[0,0,1]],-20],4,1],[3,"4c0DhYTYZF06HhZcGRu0sa",1,0],[1,-38,16,0]],[121,"12345",2,20,20,1,false,1,4,[0,"ddIY+NJvlDTIQAg7PLVrGo"]],[122,"000",0,20,20,32,1,false,5,[0,"8fhi7qRLFJbK0abIJuXmCW"],[4,4290493371]]],0,[0,8,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,0,2,0,0,2,0,21,7,0,22,6,0,0,2,0,0,2,0,-1,4,0,-2,5,0,0,3,0,0,3,0,0,3,0,0,4,0,-2,6,0,0,5,0,-2,7,0,16,1,20],[0,0,0],[1,26,1],[13,13,25]],[[[320,"凯瑟喵 - 撒野（伴奏）",".mp3",248.137143]],0,0,[],[],[]],[[[27,"demandItem"],[96,"demandItem",33554432,[-5,-6,-7],[[1,-2,[0,"c68UOAlNhN171Umca6yVvF"],[5,1260,32]],[33,40,10,10,47.8,380,-3,[0,"f4Ox7SrotLAbSxr+P1fiix"]],[321,-4]],[3,"88uwYuFfFE2KCQtjT7EVQg",-1,0],[1,0,-242.24,0]],[20,".key",33554432,1,[[2,-8,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,203.60000000000002,25.2],[0,0,0.5]],[229,20,"前置科技 <color=#acdaff>甲烷喷射器 II</color>",20,false,-9,[0,"b5LFduq8VJWo/DE4BRFmBn"],0,1,2],[104,8,3.149999999999997,380,-10,[0,"12wDXNr/pNvrWv3M5t8qht"]]],[3,"a3MlKCXHJKSok4lo4/42b6",1,0],[1,-630,-2,0]],[52,".value",512,33554432,1,[[1,-11,[0,"c68UOAlNhN171Umca6yVvF"],[5,200,31.5]],[16,"5",2,20,20,25,3,false,1,-12,[0,"2frm37uaJHQr0AEEaYyM82"],3],[33,32,10,40,3.149999999999997,380,-13,[0,"d4bzFeWTFMupMwEByJ92tO"]]],[3,"f4ZTC++QNPt5fzcwVdVdmM",1,0],[1,490,0,0]],[20,".icon",33554432,1,[[1,-14,[0,"f7NISe7HdAD68SLfhnddy8"],[5,24,24]],[25,0,-15,[0,"e71ctEmpxFC4KlSYRZNz/a"],4],[44,32,10,3.149999999999997,380,-16,[0,"deOvMp8JlPeLExUtP68soN"]]],[3,"b5p/0oIDZGM5DqQ3cbh58r",1,0],[1,618,0,0]]],0,[0,8,1,0,0,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,0,2,0,0,2,0,0,2,0,0,3,0,0,3,0,0,3,0,0,4,0,0,4,0,0,4,0,16,1,16],[0,0,0,0,0],[2,23,55,2,1],[0,0,12,0,81]],[[[127,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{"USE_ALBEDO_MAP":true},{},{},{}],[[[{},"emissive",8,[4,4278193513],"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[19,17],[82,15]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"951249e0-9f16-456d-8b85-a6ca954da16b@6c48a","packable":true}],[5],0,[0],[13],[83]],[[[49,"dataFacility",[{"name":"基地","description":"基地是星系运行的中枢系统，提供基础资源存储容量。\n如果基地被破坏，星系所有设施都将停止运行。","cost":[[0,0,0],[5000,5000,0],[20000,10000,0]],"capacity":[[10000,10000,10000],[22000,22000,22000],[34000,34000,34000]]},{"name":"能源矿井","description":"能源矿井可以开采星球能源，供星球各项设施支撑。\n生产力与星球能源丰富度有关。","cost":[[0,500,0],[0,500,200],[0,500,400]],"capacity":[[1200,0,0],[2400,0,0],[3600,0,0]]},{"name":"晶钢矿井","description":"鲤鱼矿井可以消耗鱼饵(能量)开采星球鲤鱼，供星系各工程的使用。生产力与星球鲤鱼丰富度有关。","cost":[[0,500,0],[0,500,200],[0,500,400]],"capacity":[[0,1200,0],[0,2400,0],[0,3600,0]]},{"name":"芯髓矿井","description":"改一下介绍，注意回车符是->\n。","cost":[[0,500,0],[500,950,0],[1500,1400,0]],"capacity":[[0,0,1200],[0,0,2400],[0,0,3600]]},{"name":"行星防御系统","description":"改一下介绍，注意回车符是->\n。","cost":[[10000,10000,10000],[20000,20000,20000],[30000,30000,30000]]},{"name":"戴森球","description":"戴森球可以包裹恒星并获取恒星提供的巨大能量。\n只能建造在恒星上。","cost":[[0,12000,4000]],"capacity":[[12000,0,0]]}]]],0,0,[],[],[]],[[{"name":"default_progressbar_bg","rect":{"x":0,"y":0,"width":60,"height":15},"offset":{"x":0,"y":0},"originalSize":{"width":60,"height":15},"rotated":false,"capInsets":[10,4,10,4],"texture":"9fd900dd-221b-4f89-8f2c-fba34243c835@6c48a","packable":true}],[5],0,[0],[13],[84]],[[[27,"Settings"],[53,"Settings",33554432,[-10,-11],[[59,45,-2,[0,"b4hB1bsNxNx4+wEaNw8+bB"]],[322,-7,[-5,-6],[-3,-4]],[8,-8,[0,"349gD1lA9ELZZEsZb6+rX8"]],[1,-9,[0,"3f1JCHZoJDGL9xMt27OrCS"],[5,1280,768]]],[3,"4cxUJ/IABLJ46AmhShx5S7",-1,0]],[158,"Background",33554432,1,[-17,-18,-19,-20,-21],[[110,1,0,-12,[0,"cefMtEtgtKU5ySbyycFsuP"],48,49,50],[76,1,2,11,28,14,-13,[0,"c1NQslkVhPeKz704p8LoWc"]],[255,-14,[0,"f39W1XlGBKAZXlo9ST/jzI"]],[8,-15,[0,"fdcOSKbHlJJpqotvP5+rsm"]],[1,-16,[0,"c51xm776BHWJjrmRPN0q78"],[5,360,317.4]]],[3,"advCLInzlKTrG//LAYHB8r",1,0]],[53,"Mute",33554432,[-27,-28],[[60,1,0,-22,[0,"bdsEANCzJABZhwScz5zrFI"],[4,4291817209],10,11,12],[78,1,5,5,20,-23,[0,"88UOAjzH1OzJXxNHvrLlcL"]],[59,8,-24,[0,"99fFYx/kVM25Mbn5Fko6Gw"]],[8,-25,[0,"50iZz0ECVCNbHxLm2a9CsA"]],[2,-26,[0,"f0gIYhQNBAYKf5JbKJp2oO"],[5,114,40],[0,0,0.5]]],[3,"895uxRi1lEVJp8fZGIEHu9",1,0]],[42,"Music",33554432,2,[-34,-35],[[60,1,0,-29,[0,"6a3D77xilAm5zhQO1kGCXU"],[4,4291817209],27,28,29],[78,1,5,5,20,-30,[0,"8dcTHHNMtAUJYFhntmbgwd"]],[69,8,22,-31,[0,"16RV/IuztLc5mREBz/eeAd"]],[8,-32,[0,"1cCZFvSRRNu6KuWDzjM/eD"]],[1,-33,[0,"255/CzNh9GQYGMaGO49rU9"],[5,306,40]]],[3,"0eVZV5RDdBnKvOy/5DG+/V",1,0],[1,-5,7.299999999999983,0]],[42,"Sound",33554432,2,[-41,-42],[[60,1,0,-36,[0,"eeRX+ZKhlLrZ10VZ2QIMrg"],[4,4291817209],36,37,38],[78,1,5,5,20,-37,[0,"04Vpr6XaNFoqhhCDdMeG7U"]],[69,8,22,-38,[0,"66g0HEJ3JDLbHVyTzqPiJ/"]],[8,-39,[0,"fb8rwiyMRDB6/skynjz6wN"]],[1,-40,[0,"74+ExWARJOKIB9rkUxw3H5"],[5,306,40]]],[3,"c5PO1iJgBBgbdX+aDk653P",1,0],[1,-5,-46.70000000000002,0]],[97,"sprite_splash",33554432,1,[[202,0,-43,[0,"7dD0AdFFhOPY0Oeg+NCvNT"],[4,4278190080],0,1],[59,45,-44,[0,"f6Y8d/ELFECqYV6QjPkUlQ"]],[253,-46,[0,"03I2ZzXJRHPb28+sTCveV1"],[[10,"008d9PrPqpIhaDsOHyFgyyV","back",1]],[4,4294967295],[4,4292072403],-45,2],[230,120,-47,[0,"b9Wk9cB9BHJ6DWKsH7PRev"]],[1,-48,[0,"5aPn+j+wNH74KwgZjtBQTM"],[5,1280,768]]],[3,"f7P75JOOJAX7uglkP/RcNC",1,0]],[42,"Mute & Skip",33554432,2,[3,-53],[[241,1,20,-49,[0,"7etWL3WyVIartf0KloLdqH"]],[69,8,22,-50,[0,"90bY0SJfZNDYyOzHD6/C0L"]],[8,-51,[0,"96gjsIcXNAsL82DSpwvbhM"]],[2,-52,[0,"64uu9F9R1BHLmZXDOBmgYh"],[5,304,40],[0,0,0.5]]],[3,"aaITD9NxZJBZEDL0rVUyEa",1,0],[1,-158,61.29999999999998,0]],[159,"Skip",false,33554432,7,[-58,-59],[[60,1,0,-54,[0,"3fz6nW1h1BCqcyaQ9ClCBK"],[4,4291817209],18,19,20],[78,1,5,5,20,-55,[0,"79CRgIIlVIrYxnMm2wx4X9"]],[8,-56,[0,"d2cP7f2HtPebNMcDkHvtT/"]],[2,-57,[0,"7c5cDMGqpIQZOKfnyUaY+R"],[5,170,40],[0,0,0.5]]],[3,"2fVSZ3oMNEfJpQ46v2M7EJ",1,0],[1,134,0,0]],[53,"Background",33554432,[-64],[[60,1,0,-60,[0,"26z43zfbZLO6mP/dPCYvgy"],[4,4293322470],41,42,43],[108,45,100,40,0,-61,[0,"b8PrZxynNEEqd+QLNWsehi"]],[8,-62,[0,"b7n3pALPlOMoFifAkyw+7M"]],[1,-63,[0,"d9wsfkzFZMCpZKRFuFu5Y6"],[5,180,50]]],[3,"f1I4EIC5NMK5wdkmCvxIP3",1,0]],[67,"toggle",33554432,3,[-68,-69],[[-65,[8,-66,[0,"4474msJjpPMr8/GYI8/mEM"]],[1,-67,[0,"71g0vTHkFNSZfECOYDiWwp"],[5,28,28]]],1,4,4],[3,"30OrHnVzBNibyz7Je68Ywb",1,0],[1,95,0,0]],[67,"toggle",33554432,8,[-73,-74],[[-70,[8,-71,[0,"aaYmpQja5K2LmsKdrZ5m5M"]],[1,-72,[0,"67dElbdcRGOInNnAEATcla"],[5,28,28]]],1,4,4],[3,"afbXyVeZVOR57kJi2BpTWo",1,0],[1,151,0,0]],[67,"slider",33554432,4,[-78,-79],[[-75,[8,-76,[0,"33jsBerkVNZ7fw8gN5ouJF"]],[1,-77,[0,"a2oUkRWytCUbb1veN3CIFk"],[5,220,20]]],1,4,4],[3,"68lOw1CDJFY6mVcKbAzrhF",1,0],[1,38,0,0]],[101,"Handle",512,33554432,12,[[[70,1,0,-80,[0,"f2KVAeg7tAlqJe1i/eDl/7"],25,26],-81,[8,-82,[0,"599pN7rWZKU6HFA9qQMObG"]],[1,-83,[0,"34lVgaBZ9CNq0Q8c13cJrY"],[5,32,32]]],4,1,4,4],[3,"8b06Dt1aRCY4X9tFW09HqC",1,0],[1,1,1,0]],[67,"slider",33554432,5,[-87,-88],[[-84,[8,-85,[0,"55JdQJOo9KeqxbT34/E706"]],[1,-86,[0,"35TZ25f/BADKZCRGsWHgF5"],[5,220,20]]],1,4,4],[3,"57sz6L9+ZKvY+iXoYuaChr",1,0],[1,38,0,0]],[101,"Handle",512,33554432,14,[[[70,1,2,-89,[0,"4ezTV+2E1Lp664gUFyqlaW"],34,35],-90,[8,-91,[0,"a08Ggg1k9Jn7sa2V/Utvka"]],[1,-92,[0,"23xtrfeF9GLIQhDwUJkpCT"],[5,32,32]]],4,1,4,4],[3,"92AjFBWsJFur1OTtvJZzhQ",1,0],[1,1,1,0]],[42,"Back",33554432,2,[9],[[254,2,-93,[0,"077HIaGgNIAJEOJYmBjG2P"],[[50,"008d9PrPqpIhaDsOHyFgyyV","back","1",1]],[4,4293322470],[4,4294967295],[4,4291348680],[4,3363338360],9,44,45,46,47],[195,20,0.08821676118462501,false,-94,[0,"47Kue19ARCJK3+0UclhVsn"]],[8,-95,[0,"93AHGpoqdMZ6FEfhshamcR"]],[1,-96,[0,"b9E//2A4NE96qKVVvomA0J"],[5,180,50]]],[3,"7eyJvuauBI9oo7y9nkBzdk",1,0],[1,0,-105.70000000000002,0]],[20,"label",33554432,2,[[222,"设置",40,false,0,1,-97,[0,"f6lE/uhcRCmoru+XsKADzt"],[4,4278241279],3,4],[129,1,-98,[0,"05wu2i1mFAio42kyFHe+jM"]],[8,-99,[0,"0cdkWgUOpJpr7CpsP5LjeC"]],[1,-100,[0,"8c9HLvdf9CA7nA1AkO5UBe"],[5,82,52.4]]],[3,"f4hv6g72tLSbKgddRUbIhh",1,0],[1,0,121.49999999999999,0]],[98,"Background",512,33554432,10,[[114,-101,[0,"ebmg+I28NL65dyntpnxufo"],7,8,9],[8,-102,[0,"fdfTzQoR1IuabrMv+faj3p"]],[1,-103,[0,"c0ggxckS9GIYMNvGzmT0Kc"],[5,28,28]]],[3,"ffjkuthJRP0LdRtVXZyaT6",1,0],[1,1,1,0]],[98,"Background",512,33554432,11,[[114,-104,[0,"f5jNA4qVhEZq6X3qRRRcR+"],15,16,17],[8,-105,[0,"71lZf7r4lNHo4g2gHBGvpP"]],[1,-106,[0,"f5veS1hfBLNpb45Jo4newG"],[5,28,28]]],[3,"29R+DOJI5NMbwZ403xjFkB",1,0],[1,1,1,0]],[20,"label",33554432,3,[[91,"静音",28,28,28,false,0,1,-107,[0,"02q2aAVGxCvYGxLBaXBrVC"],5,6],[8,-108,[0,"416dQNjr5FwoJ4U6eOtuXD"]],[1,-109,[0,"b1W4UKgaBESaOUpXs5gYBZ"],[5,56,35.28]]],[3,"1c5wtCAXpNHbOOyuYJgIZ2",1,0],[1,33,0,0]],[102,"checkmark",512,33554432,10,[[-110,[8,-111,[0,"00pZNfGu9Ewaqwmz+oTMz8"]],[1,-112,[0,"7aak69T3hLk4o1+HA0uZgh"],[5,28,28]]],1,4,4],[3,"6ctnSeQMFFBLUP6MAYySvU",1,0]],[20,"label",33554432,8,[[223,"跳过剧情",28,28,28,false,0,1,-113,[0,"ceGqJ9skxGSLj2yktRUpom"],[4,4282615841],13,14],[8,-114,[0,"3e3T+wKqtJUbjkOhRpydAJ"]],[1,-115,[0,"4fekqsJ2FC5JrRpO4litGO"],[5,112,35.28]]],[3,"ceQ6pw0pJD5o3riwtE3vQG",1,0],[1,61,0,0]],[102,"checkmark",512,33554432,11,[[-116,[8,-117,[0,"e3Ma57vR9KSpLk7JgQELv1"]],[1,-118,[0,"441pVcpO5IsL8FvyZ0WUaq"],[5,28,28]]],1,4,4],[3,"d1znmRnCdJNYtx8ukwnagl",1,0]],[20,"label",33554432,4,[[91,"音量",28,28,28,false,0,1,-119,[0,"5eW2DTYLFAzaNJe6DoEIie"],21,22],[8,-120,[0,"493F9zYq9LKY//xjEndmfG"]],[1,-121,[0,"a3TGXD4slDFJ2w17MMQ1bv"],[5,56,35.28]]],[3,"09KsqNdm1ARJVg7OIBWJSw",1,0],[1,-120,0,0]],[83,"Background",512,33554432,12,[[70,1,0,-122,[0,"a6nlV+53ZJYpBrL71th9kG"],23,24],[8,-123,[0,"6cBc3JQfdF+I1YRu32+Dwt"]],[1,-124,[0,"96ZN9pXdVOnqhFQLM8yLwM"],[5,220,20]]],[3,"49wT21GzRElY56oEsjk0bl",1,0]],[20,"label",33554432,5,[[91,"音效",28,28,28,false,0,1,-125,[0,"38DTcTA2xOFK1C0TJ2KGo0"],30,31],[8,-126,[0,"95mPq66hVH+rMyrnHKwH/h"]],[1,-127,[0,"02qjbnKJNHR5rU0rkyggwD"],[5,56,35.28]]],[3,"a7ieVRYNJLqYknEX3r6vGd",1,0],[1,-120,0,0]],[83,"Background",512,33554432,14,[[70,1,0,-128,[0,"a6nlV+53ZJYpBrL71th9kG"],32,33],[8,-129,[0,"752pl7b3RM8IcH8Ymf4nt4"]],[1,-130,[0,"c7kHdZMGFKorUvviPeDfWL"],[5,220,20]]],[3,"6bqjBkBw5G+YifrLQeTA8E",1,0]],[97,"Label",33554432,9,[[224,"返回游戏",35,35,1,false,false,0,1,-131,[0,"b85uLpBkRIv7G5eAlzAoQE"],39,40],[8,-132,[0,"78NFPaUKVGmJgZh9vw0xel"]],[1,-133,[0,"70MFqPnKpJ/4tPZMVRfDFD"],[5,160,40]]],[3,"5982FTWEBOjIfm9RpIhxnW",1,0]],[115,2,false,21,[0,"1cckPk3OtNhbJXOU2H/1e0"]],[135,3,10,[0,"6fVTAmLH1DK7MOVGf7MF6L"],[4,4292269782],[4,4294967295],[4,4292072403],18,[[10,"008d9PrPqpIhaDsOHyFgyyV","setMute",1]],29],[115,2,false,23,[0,"0fZhOfFhRDxJHQX9YPS6sp"]],[135,3,11,[0,"bcYbtOg59LoqoF1Q6hiaxG"],[4,4292269782],[4,4294967295],[4,4292072403],19,[[10,"008d9PrPqpIhaDsOHyFgyyV","setSkip",1]],31],[131,3,1.1,13,[0,"5aJRwrdzRLqKCmgiAHPoVw"],[4,4294967295],[4,4294967295],13],[147,0.5,12,[0,"81HXx+hW5A5qjYt2UesGiA"],[[10,"008d9PrPqpIhaDsOHyFgyyV","setMusicVolume",1]],33],[131,3,1.1,15,[0,"30sCC4daRJoYMq7LtcbEys"],[4,4294967295],[4,4294967295],15],[147,0.5,14,[0,"3aGYJhbgZCVJHT73bjOM/T"],[[10,"008d9PrPqpIhaDsOHyFgyyV","setSoundVolume",1]],35]],0,[0,8,1,0,0,1,0,-1,34,0,-2,36,0,-1,30,0,-2,32,0,0,1,0,0,1,0,0,1,0,-1,6,0,-2,2,0,0,2,0,0,2,0,0,2,0,0,2,0,0,2,0,-1,17,0,-2,7,0,-3,4,0,-4,5,0,-5,16,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,-1,20,0,-2,10,0,0,4,0,0,4,0,0,4,0,0,4,0,0,4,0,-1,24,0,-2,12,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,-1,26,0,-2,14,0,0,6,0,0,6,0,12,6,0,0,6,0,0,6,0,0,6,0,0,7,0,0,7,0,0,7,0,0,7,0,-2,8,0,0,8,0,0,8,0,0,8,0,0,8,0,-1,22,0,-2,11,0,0,9,0,0,9,0,0,9,0,0,9,0,-1,28,0,-1,30,0,0,10,0,0,10,0,-1,18,0,-2,21,0,-1,32,0,0,11,0,0,11,0,-1,19,0,-2,23,0,-1,34,0,0,12,0,0,12,0,-1,25,0,-2,13,0,0,13,0,-2,33,0,0,13,0,0,13,0,-1,36,0,0,14,0,0,14,0,-1,27,0,-2,15,0,0,15,0,-2,35,0,0,15,0,0,15,0,0,16,0,0,16,0,0,16,0,0,16,0,0,17,0,0,17,0,0,17,0,0,17,0,0,18,0,0,18,0,0,18,0,0,19,0,0,19,0,0,19,0,0,20,0,0,20,0,0,20,0,-1,29,0,0,21,0,0,21,0,0,22,0,0,22,0,0,22,0,-1,31,0,0,23,0,0,23,0,0,24,0,0,24,0,0,24,0,0,25,0,0,25,0,0,25,0,0,26,0,0,26,0,0,26,0,0,27,0,0,27,0,0,27,0,0,28,0,0,28,0,0,28,0,16,1,3,5,7,9,5,16,133],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,29,31,31,33,33,33,33,35,35,35,35],[7,1,6,7,2,7,2,7,1,14,7,1,14,7,2,7,1,14,7,1,14,7,2,7,1,7,1,7,1,14,7,2,7,1,7,1,7,1,14,7,2,7,1,14,6,9,10,11,7,1,14,7,1,7,1,6,9,10,11,6,9,10,11],[1,14,14,1,0,1,0,1,38,6,1,2,6,1,0,1,38,6,1,17,6,1,0,1,39,1,8,1,2,6,1,0,1,39,1,8,1,2,6,1,0,1,2,6,2,4,5,3,1,7,6,1,40,1,40,8,8,8,11,8,8,8,11]],[[[323,"loading",3,2,1.3333333333333333,3871878643,[[0,0.3333333333333333,0.6666666666666666,1,1.3333333333333333]],[[[{"data":{"keys":0,"values":["读取数据中","读取数据中.","读取数据中..","读取数据中...","读取数据中"],"easingMethods":{}}},"modifiers",12,[[[324,"cc.Label"],"string"],4,0]]],11]]],0,0,[],[],[]],[[{"name":"default_scrollbar_vertical","rect":{"x":0,"y":0,"width":15,"height":30},"offset":{"x":0,"y":0},"originalSize":{"width":15,"height":30},"rotated":false,"capInsets":[4,10,4,10],"texture":"afc47931-f066-46b0-90be-9fe61f213428@6c48a","packable":true}],[5],0,[0],[13],[85]],[[{"name":"iconset","spriteFrames":["btn_back","bad5f427-d743-46cb-84c3-5df9d3a9897c@d3735","btn_continue","bad5f427-d743-46cb-84c3-5df9d3a9897c@73991","btn_pause","bad5f427-d743-46cb-84c3-5df9d3a9897c@b27e7","fac_down","bad5f427-d743-46cb-84c3-5df9d3a9897c@25e4d","fac_fix","bad5f427-d743-46cb-84c3-5df9d3a9897c@8a970","fac_remove","bad5f427-d743-46cb-84c3-5df9d3a9897c@c3f25","fac_up","bad5f427-d743-46cb-84c3-5df9d3a9897c@a0e01","icon_res_0","bad5f427-d743-46cb-84c3-5df9d3a9897c@9bce9","icon_res_1","bad5f427-d743-46cb-84c3-5df9d3a9897c@d1a7c","icon_res_2","bad5f427-d743-46cb-84c3-5df9d3a9897c@94fc1","judge_false","bad5f427-d743-46cb-84c3-5df9d3a9897c@8b68e","judge_true","bad5f427-d743-46cb-84c3-5df9d3a9897c@9cd14","res_add_0","bad5f427-d743-46cb-84c3-5df9d3a9897c@45e1a","res_add_1","bad5f427-d743-46cb-84c3-5df9d3a9897c@6d5ac","res_add_2","bad5f427-d743-46cb-84c3-5df9d3a9897c@5b23e","res_sto","bad5f427-d743-46cb-84c3-5df9d3a9897c@dab52","res_sto_0","bad5f427-d743-46cb-84c3-5df9d3a9897c@443e8","res_sto_1","bad5f427-d743-46cb-84c3-5df9d3a9897c@91024","res_sto_2","bad5f427-d743-46cb-84c3-5df9d3a9897c@066ad","res_sub_0","bad5f427-d743-46cb-84c3-5df9d3a9897c@8dcfc","ui_to","bad5f427-d743-46cb-84c3-5df9d3a9897c@0e6b5"]}],[19],0,[],[],[]],[[{"name":"default_editbox_bg","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"bd1bcaba-bd7d-4a71-b143-997c882383e4@6c48a","packable":true}],[5],0,[0],[13],[86]],[[[124,"builtin-particle",[{"hash":1755172438,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":3314483928,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":3916783067,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":37}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":1118626722,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":37}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[[49,"dataSolar",[{"name":"太阳","radius":696000,"radiusType":4,"orbitalRadius":0,"texture":"Sun-Mi","ring":"","orbitalAngularVelocity":0,"spinVelocity":0.5988,"abundance":[246,0,0],"hard":[0,0,0]},{"name":"水星","radius":2440,"radiusType":1,"orbitalRadius":0.3871,"texture":"Mercury-Mi","ring":"","orbitalAngularVelocity":4.09,"spinVelocity":0.2557,"abundance":[38,22,15],"hard":[0,0,1]},{"name":"金星","radius":6052,"radiusType":2,"orbitalRadius":0.723,"texture":"Venus-Mi","ring":"","orbitalAngularVelocity":1.6,"spinVelocity":0.0617,"abundance":[36,28,15],"hard":[0,1,2]},{"name":"地球","radius":6378,"radiusType":2,"orbitalRadius":1,"texture":"Earth","ring":"","orbitalAngularVelocity":0.98,"spinVelocity":15.041,"abundance":[32,20,18],"hard":[0,1,2]},{"name":"火星","radius":3397,"radiusType":1,"orbitalRadius":1.5237,"texture":"Mars-Mi","ring":"","orbitalAngularVelocity":0.52,"spinVelocity":14.6204,"abundance":[42,26,15],"hard":[0,1,2]},{"name":"木星","radius":71492,"radiusType":4,"orbitalRadius":5.2026,"texture":"Jupiter-Mi","ring":"","orbitalAngularVelocity":0.083,"spinVelocity":36.272,"abundance":[44,27,20],"hard":[0,1,2]},{"name":"土星","radius":60268,"radiusType":4,"orbitalRadius":9.5549,"texture":"Saturn","ring":"ring","orbitalAngularVelocity":0.033,"spinVelocity":33.7831,"abundance":[42,28,20],"hard":[0,1,2]},{"name":"天王星","radius":25559,"radiusType":4,"orbitalRadius":19.2184,"texture":"Uranus-Mi","ring":"","orbitalAngularVelocity":0.012,"spinVelocity":20.8817,"abundance":[37,27,20],"hard":[0,1,2]},{"name":"海王星","radius":24764,"radiusType":4,"orbitalRadius":30.1104,"texture":"Neptune-Mi","ring":"","orbitalAngularVelocity":0.006,"spinVelocity":22.3463,"abundance":[37,27,20],"hard":[0,1,2]}]]],0,0,[],[],[]],[[[232,[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[19,17],[36,87]],[[{"name":"default_radio_button_off","rect":{"x":3,"y":3,"width":26,"height":26},"offset":{"x":0,"y":0},"originalSize":{"width":32,"height":32},"rotated":false,"capInsets":[13,13,13,13],"texture":"f12a23c4-b924-4322-a260-3d982428f1e8@6c48a","packable":true}],[5],0,[0],[13],[88]],[[[233,[{}],[{"USE_TEXTURE":true}]]],0,0,[0],[17],[89]],[[[27,"ResourceItem"],[53,"ResourceItem",33554432,[-6,-7,-8,-9],[[1,-2,[0,"71kmounFRG/K27WWBbH2RB"],[5,180,50]],[8,-3,[0,"7eyNuUmkdL+b+b9M5t5Ruv"]],[13,1,0,-4,[0,"19AX0eCk5P/72q45ZifH2A"],4],[325,-5,[0,"d9YY3SnEhAGrD8V2jUlCZI"]]],[3,"12BtlrGU9Kp6cfll4JHAJN",-1,0]],[42,".progress",33554432,1,[-15],[[1,-10,[0,"0a4TUb2bBHBa3wO6MCw2d2"],[5,120,10]],[90,1,0,-11,[0,"e3LBidlN9MdpNxB8lzYZv7"],[4,4279842048],1],[326,120,1,-13,[0,"3f/uAXDzRCkYMASuN3GC61"],-12],[196,44,50,10,8,100,-14,[0,"1eiZZK6qdNVa9C2cR8Sob5"]]],[3,"82bxjsN/JG35wDJM4t6xwc",1,0],[1,20,-12,0]],[20,".icon",33554432,1,[[1,-16,[0,"f7NISe7HdAD68SLfhnddy8"],[5,32,32]],[25,0,-17,[0,"e71ctEmpxFC4KlSYRZNz/a"],0],[69,10,10,-18,[0,"a57pez9klBnoZBCOAVPlUJ"]]],[3,"40h1HypR9MfrBYBZeaAntC",1,0],[1,-64,0,0]],[65,"Bar",33554432,2,[[[2,-19,[0,"80SdIywIVFupwJOwCni0ux"],[5,120,10],[0,0,0.5]],-20,[197,13,12,-21,[0,"50qt2uBvZCO6bjTmlfRal8"]]],4,1,4],[3,"0bdeRZ4rVIoKDYt25r1yoZ",1,0],[1,-60,0,0]],[20,".value",33554432,1,[[2,-22,[0,"c68UOAlNhN171Umca6yVvF"],[5,60.37,37.8],[0,0,1]],[16,"12000",0,20,20,30,3,false,1,-23,[0,"2frm37uaJHQr0AEEaYyM82"],2],[58,41,49.63,70,380,-24,[0,"42uZcuCLVGu71OfTreFKeG"]]],[3,"c4gJoKK35Aibf3qSBNEu6L",1,0],[1,-40.37,25,0]],[20,".addition",33554432,1,[[2,-25,[0,"c68UOAlNhN171Umca6yVvF"],[5,60,37.8],[0,0,1]],[16,"+665.7",2,16,16,30,3,false,1,-26,[0,"2frm37uaJHQr0AEEaYyM82"],3],[58,33,49.63,10,380,-27,[0,"c96LR9GvZPLp9EVN2xw6cA"]]],[3,"62MYZ/kLxOxKquvZepfp+t",1,0],[1,20,25,0]],[113,1,0,4,[0,"e00niSjJdHzqQfr6Uq+1as"],[4,4286833245]]],0,[0,8,1,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,3,0,-2,2,0,-3,5,0,-4,6,0,0,2,0,0,2,0,56,7,0,0,2,0,0,2,0,-1,4,0,0,3,0,0,3,0,0,3,0,0,4,0,-2,7,0,0,4,0,0,5,0,0,5,0,0,5,0,0,6,0,0,6,0,0,6,0,16,1,27],[0,0,0,0,0,7],[1,1,2,2,1,1],[25,90,0,0,91,92]]]]
